from aiogram import Router, F
from aiogram.types import Message, CallbackQuery, KeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove
from aiogram.filters import Command, CommandStart, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from models.data import Participant, Pool
from services import pool_service

router = Router()

class PoolCreation(StatesGroup):
    waiting_for_name = State()
    waiting_for_participants = State()

class PoolParticipant(StatesGroup):
    waiting_for_pool_name = State()
    waiting_for_pool_to_invite = State()

class PoolInvitation(StatesGroup):
    waiting_for_pool_name = State()
    waiting_for_code = State()

# Pool creation
@router.message(Command("create_pool"))
async def cmd_create_pool(message: Message, state: FSMContext):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –ø—É–ª–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–µ–π:", parse_mode="HTML")
    await state.set_state(PoolCreation.waiting_for_name)

@router.message(PoolCreation.waiting_for_name)
async def process_pool_name(message: Message, state: FSMContext):
    pool_name = message.text.strip()
    
    # Check if name is valid
    if not pool_name:
        await message.answer("–ù–∞–∑–≤–∞–Ω–∏–µ –ø—É–ª–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ:", parse_mode="HTML")
        return
    
    # Check if pool with this name already exists
    existing_pool = pool_service.get_pool(pool_name)
    if existing_pool:
        await message.answer(f"–ü—É–ª —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º '<b>{pool_name}</b>' —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ:", parse_mode="HTML")
        return
    
    # Save pool name
    await state.update_data(pool_name=pool_name)
    
    # Create participant object for the creator
    creator = Participant(
        user_id=message.from_user.id,
        username=message.from_user.username or message.from_user.full_name
    )
    
    # Create pool with creator as first participant
    new_pool = pool_service.create_pool(pool_name, [creator])
    
    if new_pool:
        await message.answer(
            f"‚úÖ –ü—É–ª '<b>{pool_name}</b>' —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω! –í—ã —è–≤–ª—è–µ—Ç–µ—Å—å –µ–≥–æ –ø–µ—Ä–≤—ã–º —É—á–∞—Å—Ç–Ω–∏–∫–æ–º –∏ —Å–æ–∑–¥–∞—Ç–µ–ª–µ–º.\n\n"
            f"–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–ª—è—Ç—å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –∫–æ–º–∞–Ω–¥–æ–π /add_activity\n"
            f"–ß—Ç–æ–±—ã –ø—Ä–∏–≥–ª–∞—Å–∏—Ç—å –¥—Ä—É–≥–∏—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /invite\n\n"
            f"–î—Ä—É–≥–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –º–æ–≥—É—Ç –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è —Ç–æ–ª—å–∫–æ –ø–æ –≤–∞—à–µ–º—É –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—é.",
            parse_mode="HTML"
        )
    else:
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ø—É–ª. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.", parse_mode="HTML")
    
    # End the conversation
    await state.clear()

# Join a pool
@router.message(Command("join_pool"))
async def cmd_join_pool(message: Message, state: FSMContext):
    cmd_parts = message.text.split(maxsplit=1)
    
    if len(cmd_parts) > 1:
        # Check if an invitation code was provided
        code = cmd_parts[1].strip()
        pool_name = pool_service.validate_invitation_code(code)
        
        if pool_name:
            # Proceed with joining using the code
            await process_join_with_code(message, state, pool_name, code)
            return
        else:
            await message.answer("‚ùå –ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–¥ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∫–æ–¥:", parse_mode="HTML")
            await state.set_state(PoolInvitation.waiting_for_code)
            return
    
    await message.answer(
        "–ß—Ç–æ–±—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –ø—É–ª—É, –≤–∞–º –Ω—É–∂–µ–Ω –∫–æ–¥ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è –æ—Ç —Å–æ–∑–¥–∞—Ç–µ–ª—è –ø—É–ª–∞.\n"
        "–ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –∫–æ–¥, –≤–≤–µ–¥–∏—Ç–µ –µ–≥–æ:",
        parse_mode="HTML"
    )
    await state.set_state(PoolInvitation.waiting_for_code)

@router.message(PoolInvitation.waiting_for_code)
async def process_invitation_code(message: Message, state: FSMContext):
    code = message.text.strip()
    
    # Validate invitation code
    pool_name = pool_service.validate_invitation_code(code)
    
    if not pool_name:
        await message.answer("‚ùå –ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–¥ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–¥ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.", parse_mode="HTML")
        return  # Keep the state to allow retrying
    
    await process_join_with_code(message, state, pool_name, code)

async def process_join_with_code(message: Message, state: FSMContext, pool_name: str, code: str):
    # Check if pool exists
    pool = pool_service.get_pool(pool_name)
    if not pool:
        await message.answer(f"‚ùå –ü—É–ª —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º '<b>{pool_name}</b>' –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–¥ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.", parse_mode="HTML")
        await state.clear()
        return
    
    # Check if user is already a participant
    for participant in pool.participants:
        if participant.user_id == message.from_user.id:
            await message.answer(f"–í—ã —É–∂–µ —è–≤–ª—è–µ—Ç–µ—Å—å —É—á–∞—Å—Ç–Ω–∏–∫–æ–º –ø—É–ª–∞ '<b>{pool_name}</b>'.", parse_mode="HTML")
            await state.clear()
            return
    
    # Add user to the pool
    new_participant = Participant(
        user_id=message.from_user.id,
        username=message.from_user.username or message.from_user.full_name
    )
    
    success = pool_service.add_participant(pool_name, new_participant)
    
    if success:
        await message.answer(f"‚úÖ –í—ã —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–∏—Å—å –∫ –ø—É–ª—É '<b>{pool_name}</b>'!", parse_mode="HTML")
        
        # Remove the used invitation code
        try:
            storage = pool_service._get_storage()
            if pool_name in storage.pools and hasattr(storage.pools[pool_name], 'invites'):
                # Clean the code input to ensure it matches
                clean_code = code.strip()
                if clean_code in storage.pools[pool_name].invites:
                    del storage.pools[pool_name].invites[clean_code]
                    pool_service._save_storage(storage)
        except Exception:
            # If code removal fails, it's not critical - log it but continue
            pass
    else:
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –ø—É–ª—É. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.", parse_mode="HTML")
    
    await state.clear()

@router.message(PoolParticipant.waiting_for_pool_name)
async def process_join_pool(message: Message, state: FSMContext):
    pool_name = message.text.strip()
    
    # Check if pool exists
    pool = pool_service.get_pool(pool_name)
    if not pool:
        await message.answer(f"‚ùå –ü—É–ª —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º '<b>{pool_name}</b>' –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.", parse_mode="HTML")
        await state.clear()
        return
    
    # Check if user is already a participant
    for participant in pool.participants:
        if participant.user_id == message.from_user.id:
            await message.answer(f"–í—ã —É–∂–µ —è–≤–ª—è–µ—Ç–µ—Å—å —É—á–∞—Å—Ç–Ω–∏–∫–æ–º –ø—É–ª–∞ '<b>{pool_name}</b>'.", parse_mode="HTML")
            await state.clear()
            return
    
    # Check if user is authorized to join (must be the creator or use invite code)
    if not pool_service.is_user_authorized_for_pool(pool_name, message.from_user.id):
        await message.answer(
            f"‚ùå –î–ª—è –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∫ –ø—É–ª—É '<b>{pool_name}</b>' —Ç—Ä–µ–±—É–µ—Ç—Å—è –∫–æ–¥ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è –æ—Ç —Å–æ–∑–¥–∞—Ç–µ–ª—è –ø—É–ª–∞.\n"
            f"–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /join_pool —Å –∫–æ–¥–æ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è.",
            parse_mode="HTML"
        )
        await state.clear()
        return
    
    # Add user to the pool
    new_participant = Participant(
        user_id=message.from_user.id,
        username=message.from_user.username or message.from_user.full_name
    )
    
    success = pool_service.add_participant(pool_name, new_participant)
    
    if success:
        await message.answer(f"‚úÖ –í—ã —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–∏—Å—å –∫ –ø—É–ª—É '<b>{pool_name}</b>'!", parse_mode="HTML")
    else:
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –ø—É–ª—É. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.", parse_mode="HTML")
    
    await state.clear()

# Exit a pool
@router.message(Command("exit_pool"))
async def cmd_exit_pool(message: Message, state: FSMContext):
    user_pools = pool_service.get_pools_by_participant(message.from_user.id)
    
    if not user_pools:
        await message.answer("–í—ã –Ω–µ —è–≤–ª—è–µ—Ç–µ—Å—å —É—á–∞—Å—Ç–Ω–∏–∫–æ–º –Ω–∏ –æ–¥–Ω–æ–≥–æ –ø—É–ª–∞.", parse_mode="HTML")
        return
    
    pool_list = "\n".join([f"{i+1}. <b>{pool.name}</b>" for i, pool in enumerate(user_pools)])
    
    await message.answer(f"–í—ã–±–µ—Ä–∏—Ç–µ –ø—É–ª, –∏–∑ –∫–æ—Ç–æ—Ä–æ–≥–æ —Ö–æ—Ç–∏—Ç–µ –≤—ã–π—Ç–∏ (–≤–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä):\n{pool_list}", parse_mode="HTML")
    await state.set_state(PoolParticipant.waiting_for_pool_name)
    await state.update_data(user_pools=user_pools)

@router.message(F.text.regexp(r"^\d+$"), PoolParticipant.waiting_for_pool_name)
async def process_exit_pool(message: Message, state: FSMContext):
    data = await state.get_data()
    user_pools = data.get("user_pools", [])
    
    try:
        index = int(message.text) - 1
        if 0 <= index < len(user_pools):
            selected_pool = user_pools[index]
            
            success = pool_service.remove_participant(selected_pool.name, message.from_user.id)
            
            if success:
                await message.answer(f"‚úÖ –í—ã —É—Å–ø–µ—à–Ω–æ –≤—ã—à–ª–∏ –∏–∑ –ø—É–ª–∞ '<b>{selected_pool.name}</b>'.", parse_mode="HTML")
            else:
                await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–π—Ç–∏ –∏–∑ –ø—É–ª–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.", parse_mode="HTML")
        else:
            await message.answer("‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –Ω–æ–º–µ—Ä –ø—É–ª–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–º–µ—Ä –∏–∑ —Å–ø–∏—Å–∫–∞.", parse_mode="HTML")
    except ValueError:
        await message.answer("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –ø—É–ª–∞ –∏–∑ —Å–ø–∏—Å–∫–∞.", parse_mode="HTML")
    
    await state.clear()

# Show user's pools
@router.message(Command("my_pools"))
async def cmd_my_pools(message: Message):
    user_pools = pool_service.get_pools_by_participant(message.from_user.id)
    
    if not user_pools:
        await message.answer("–í—ã –Ω–µ —è–≤–ª—è–µ—Ç–µ—Å—å —É—á–∞—Å—Ç–Ω–∏–∫–æ–º –Ω–∏ –æ–¥–Ω–æ–≥–æ –ø—É–ª–∞.", parse_mode="HTML")
        return
    
    response = "üìã <b>–í–∞—à–∏ –ø—É–ª—ã</b>:\n\n"
    
    for i, pool in enumerate(user_pools):
        activities_count = len(pool.activities)
        participants_count = len(pool.participants)
        
        response += (
            f"{i+1}. <b>{pool.name}</b>\n"
            f"   –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç–µ–π: {activities_count}\n"
            f"   –£—á–∞—Å—Ç–Ω–∏–∫–æ–≤: {participants_count}\n\n"
        )
    
    response += "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /pool_info [–Ω–∞–∑–≤–∞–Ω–∏–µ –ø—É–ª–∞] –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏."
    
    await message.answer(response, parse_mode="HTML")

# Invite to pool
@router.message(Command("invite"))
async def cmd_invite(message: Message, state: FSMContext):
    """Handle /invite command - allow pool creators to invite others to their pools"""
    user_id = message.from_user.id
    
    # Get pools where user is the creator
    user_pools = pool_service.get_pools_by_creator(user_id)
    
    if not user_pools:
        await message.answer("–£ –≤–∞—Å –Ω–µ—Ç —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö –ø—É–ª–æ–≤. –°–æ–∑–¥–∞–π—Ç–µ –ø—É–ª —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã /create_pool", parse_mode="HTML")
        return
    
    # Create pool selection keyboard
    kb = []
    for pool in user_pools:
        kb.append([KeyboardButton(text=pool.name)])
    kb.append([KeyboardButton(text="–û—Ç–º–µ–Ω–∞")])
    
    markup = ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True, one_time_keyboard=True)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –ø—É–ª, –≤ –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ –ø—Ä–∏–≥–ª–∞—Å–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞:", reply_markup=markup, parse_mode="HTML")
    await state.set_state(PoolParticipant.waiting_for_pool_to_invite)

@router.message(PoolParticipant.waiting_for_pool_to_invite)
async def process_invite_pool_selection(message: Message, state: FSMContext):
    if message.text == "–û—Ç–º–µ–Ω–∞":
        await state.clear()
        await message.answer("–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.", reply_markup=ReplyKeyboardRemove(), parse_mode="HTML")
        return

    user_id = message.from_user.id
    pool_name = message.text
    
    # Get the pool by name and creator ID
    pool = pool_service.get_pool_by_name_and_creator(pool_name, user_id)
    
    if not pool:
        await message.answer("–ü—É–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –≤—ã –Ω–µ —è–≤–ª—è–µ—Ç–µ—Å—å –µ–≥–æ —Å–æ–∑–¥–∞—Ç–µ–ª–µ–º. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.", 
                            reply_markup=ReplyKeyboardRemove(), parse_mode="HTML")
        await state.clear()
        return
        
    # Generate invitation code
    try:
        invitation_code = pool_service.generate_invitation_code(user_id, pool.name)
        # Use HTML instead of Markdown for more reliable formatting
        await message.answer(
            f"–ö–æ–¥ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è –¥–ª—è –ø—É–ª–∞ '<b>{pool.name}</b>':\n\n"
            f"<code>{invitation_code}</code>\n\n"
            f"–ü–æ–¥–µ–ª–∏—Ç–µ—Å—å —ç—Ç–∏–º –∫–æ–¥–æ–º —Å —á–µ–ª–æ–≤–µ–∫–æ–º, –∫–æ—Ç–æ—Ä–æ–≥–æ —Ö–æ—Ç–∏—Ç–µ –ø—Ä–∏–≥–ª–∞—Å–∏—Ç—å. "
            f"–û–Ω–∏ –º–æ–≥—É—Ç –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã /join_pool:\n\n"
            f"<code>/join_pool {invitation_code}</code>",
            parse_mode="HTML",
            reply_markup=ReplyKeyboardRemove()
        )
    except Exception as e:
        await message.answer(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–¥–∞ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è: {str(e)}", 
                            reply_markup=ReplyKeyboardRemove(), parse_mode="HTML")
    
    await state.clear() 