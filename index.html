<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lilith's House - Interactive Exploration 💕</title>
    <style>
        /* ============================================
           PIXEL-ART MINIMALISTIC DESIGN SYSTEM
           ============================================ */

        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=VT323&family=Inter:wght@400;500;600&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Pixel Art Color Palette */
            --bg-dark: #0a0a0a;
            --bg-medium: #1a1a1a;
            --bg-light: #2a2a2a;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --accent-gold: #ffd700;
            --accent-pink: #ff69b4;
            --accent-blue: #4a90e2;
            --success: #4caf50;
            --warning: #ff9800;
            --error: #f44336;

            /* Dimensions */
            --tile-size: 256px;
            --location-size: 1024px; /* 4x4 tiles */
            --desktop-viewport-height: 50vh; /* Half location visible */
            --mobile-viewport-height: 100vh; /* Full location visible */

            /* Transitions */
            --transition-fast: 0.15s ease;
            --transition-normal: 0.3s ease;
            --transition-slow: 0.5s ease;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            overflow-x: hidden;
            position: relative;
        }

        /* ============================================
           MAIN CONTAINER & SCROLL SYSTEM
           ============================================ */

        .world-container {
            width: 100%;
            height: 100vh;
            overflow-y: auto;
            overflow-x: hidden;
            scroll-behavior: smooth;
            scroll-snap-type: y mandatory;
        }

        .locations-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0;
            min-height: 100vh;
        }

        .location-section {
            width: 100%;
            min-height: var(--desktop-viewport-height);
            scroll-snap-align: start;
            scroll-snap-stop: always;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: var(--bg-dark);
        }

        .location-container {
            width: var(--location-size);
            height: var(--location-size);
            position: relative;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: transform var(--transition-normal);
        }

        /* Responsive Layout */
        @media (max-width: 768px) {
            .location-section {
                min-height: var(--mobile-viewport-height);
                margin: 0;
                padding: 0;
            }

            .location-container {
                width: 100vw;
                height: 100vh;
                max-width: 100vw;
                max-height: 100vh;
                margin: 0;
                padding: 0;
            }

            .world-container {
                margin: 0;
                padding: 0;
            }

            body {
                margin: 0;
                padding: 0;
            }
        }

        /* ============================================
           WIDGET INTERACTION SYSTEM
           ============================================ */

        .widget-area {
            position: absolute;
            cursor: pointer;
            transition: all var(--transition-fast);
            z-index: 10;
        }

        .widget-area:hover {
            transform: scale(1.05);
            filter: brightness(1.2) drop-shadow(0 0 10px var(--accent-pink));
        }

        .widget-area:active {
            transform: scale(0.95);
            filter: brightness(1.3) drop-shadow(0 0 15px var(--accent-gold));
        }

        .widget-group {
            position: absolute;
            pointer-events: none;
            transition: all var(--transition-fast);
        }

        .widget-group.hover {
            filter: brightness(1.2) drop-shadow(0 0 15px var(--accent-pink));
            transform: scale(1.02);
        }

        .widget-group.click {
            filter: brightness(1.4) drop-shadow(0 0 20px var(--accent-gold));
            transform: scale(1.05);
        }

        /* Easter Egg Hidden Zones */
        .easter-egg-zone {
            position: absolute;
            cursor: pointer;
            opacity: 0.2;
            transition: all var(--transition-normal);
            z-index: 15;
            scroll-margin: 50px; /* Help scroll into view */
        }

        .easter-egg-zone:hover {
            opacity: 0.8;
            filter: drop-shadow(0 0 15px var(--accent-gold));
            transform: scale(1.1);
        }

        .easter-egg-zone.found {
            opacity: 1;
            pointer-events: none;
            z-index: 20;
        }

        /* ============================================
           FLOOR NAVIGATION GUI
           ============================================ */

        .floor-navigation {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(42, 42, 42, 0.95);
            border: 2px solid var(--accent-pink);
            border-radius: 8px;
            padding: 16px;
            z-index: 50;
            font-family: 'VT323', monospace;
            font-size: 18px;
            backdrop-filter: blur(10px);
            min-width: 150px;
            pointer-events: none; /* Allow clicks through to widgets */
        }

        .floor-title {
            color: var(--accent-pink);
            margin-bottom: 12px;
            text-align: center;
            font-size: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .floor-button {
            display: block;
            width: 100%;
            padding: 8px 12px;
            margin: 4px 0;
            background: var(--bg-light);
            border: 1px solid var(--text-secondary);
            border-radius: 4px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all var(--transition-fast);
            font-family: 'VT323', monospace;
            font-size: 16px;
            text-align: center;
            pointer-events: auto; /* Re-enable clicks for floor buttons */
        }

        .floor-button:hover {
            background: var(--accent-pink);
            color: var(--bg-dark);
            border-color: var(--accent-pink);
            transform: translateX(-4px);
        }

        .floor-button.active {
            background: var(--accent-pink);
            color: var(--bg-dark);
            border-color: var(--accent-gold);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .floor-navigation {
                right: 10px;
                padding: 12px;
                min-width: 120px;
                font-size: 16px;
            }

            .floor-title {
                font-size: 18px;
                margin-bottom: 8px;
            }

            .floor-button {
                padding: 6px 8px;
                font-size: 14px;
            }
        }

        /* ============================================
           MODAL SYSTEM (PIXEL-ART STYLE)
           ============================================ */

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.001);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-normal);
            padding: 20px;
        }

        .modal-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .modal-container {
            background: var(--bg-dark);
            border: 4px solid var(--accent-pink);
            border-radius: 0;
            max-width: 800px;
            max-height: 80vh;
            width: 100%;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(255, 105, 180, 0.5);
            position: relative;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .modal-header {
            background: var(--accent-pink);
            color: var(--bg-dark);
            padding: 16px 20px;
            font-family: 'VT323', monospace;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--bg-dark);
            font-size: 24px;
            cursor: pointer;
            padding: 4px 8px;
            font-family: 'VT323', monospace;
            transition: all var(--transition-fast);
        }

        .modal-close:hover {
            background: var(--accent-gold);
            transform: scale(1.1);
        }

        .modal-content {
            padding: 20px;
            max-height: calc(80vh - 80px);
            overflow-y: auto;
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
        }

        .modal-content img {
            max-width: 100%;
            height: auto;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            border: 2px solid var(--accent-pink);
            margin: 10px 0;
        }

        .modal-content h1, .modal-content h2, .modal-content h3 {
            color: var(--accent-pink);
            margin-top: 20px;
            margin-bottom: 10px;
            font-family: 'VT323', monospace;
        }

        .modal-content h1 { font-size: 32px; }
        .modal-content h2 { font-size: 28px; }
        .modal-content h3 { font-size: 24px; }

        .modal-content p {
            margin-bottom: 12px;
            color: #333333; /* Dark text for transparent modal background */
        }

        .modal-content a {
            color: var(--accent-blue);
            text-decoration: none;
            border-bottom: 1px solid var(--accent-blue);
            transition: all var(--transition-fast);
        }

        .modal-content a:hover {
            color: var(--accent-gold);
            border-bottom-color: var(--accent-gold);
        }

        .modal-content code {
            background: var(--bg-light);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'VT323', monospace;
            color: var(--accent-gold);
        }

        .modal-content pre {
            background: var(--bg-light);
            padding: 16px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 12px 0;
        }

        .modal-content pre code {
            background: none;
            padding: 0;
            color: #333333; /* Dark text for transparent modal background */
        }

        /* ============================================
           DARK SOULS LOCATION DISCOVERY
           ============================================ */

        .location-discovery {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-slow);
        }

        .location-discovery.active {
            opacity: 1;
            pointer-events: all;
            animation: discoveryPulse 4s ease forwards;
        }

        @keyframes discoveryPulse {
            0% { opacity: 0; }
            15% { opacity: 1; }
            85% { opacity: 1; }
            100% { opacity: 0; }
        }

        .discovery-text {
            text-align: center;
            font-family: 'Cinzel', serif;
            color: var(--accent-gold);
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            animation: textReveal 4s ease forwards;
        }

        .location-name {
            font-size: clamp(48px, 8vw, 72px);
            margin-bottom: 20px;
            letter-spacing: 8px;
            opacity: 0;
            animation: locationNameReveal 4s ease forwards;
        }

        .location-subtitle {
            font-size: clamp(24px, 4vw, 36px);
            opacity: 0;
            animation: locationSubtitleReveal 4s ease forwards;
        }

        @keyframes locationNameReveal {
            0% { opacity: 0; transform: translateY(30px) blur(10px); }
            20% { opacity: 1; transform: translateY(0) blur(0); }
            80% { opacity: 1; transform: translateY(0) blur(0); }
            100% { opacity: 0; transform: translateY(-30px) blur(10px); }
        }

        @keyframes locationSubtitleReveal {
            0% { opacity: 0; transform: translateY(20px) blur(5px); }
            30% { opacity: 1; transform: translateY(0) blur(0); }
            80% { opacity: 1; transform: translateY(0) blur(0); }
            100% { opacity: 0; transform: translateY(-20px) blur(5px); }
        }

        /* ============================================
           AUDIO SYSTEM VISUAL INDICATORS
           ============================================ */

        .audio-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(42, 42, 42, 0.95);
            border: 2px solid var(--accent-pink);
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            z-index: 50;
            font-family: 'VT323', monospace;
            font-size: 18px;
            color: var(--text-primary);
            backdrop-filter: blur(10px);
            transition: all var(--transition-fast);
        }

        .audio-toggle:hover {
            background: var(--accent-pink);
            color: var(--bg-dark);
            transform: scale(1.05);
        }

        .audio-toggle.muted {
            border-color: var(--text-secondary);
            color: var(--text-secondary);
        }

        /* ============================================
           LOADING & ERROR STATES
           ============================================ */

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'VT323', monospace;
            font-size: 24px;
            color: var(--accent-pink);
            text-align: center;
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--accent-pink);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--error);
            color: var(--text-primary);
            padding: 20px;
            border-radius: 8px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            text-align: center;
            max-width: 400px;
        }

        /* ============================================
           ENHANCED INTERACTIVE STATE MANAGEMENT
           ============================================ */

        .state-transitioning {{
            transition: all 0.2s ease-in-out;
        }}

        .state-idle-to-hover {{
            filter: brightness(1.1) saturate(1.2);
        }}

        .state-hover-to-click {{
            filter: brightness(1.2) saturate(1.3);
        }}

        .state-click-to-hover {{
            filter: brightness(1.1) saturate(1.2);
        }}

        .state-hover-to-idle {{
            filter: brightness(1.0) saturate(1.0);
        }}

        .effect-glow {{
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.5);
            animation: glow 2s ease-in-out infinite;
        }}

        .effect-pulse {{
            animation: pulse 0.5s ease-in-out;
        }}

        .effect-shake {{
            animation: shake 0.3s ease-in-out;
        }}

        @keyframes glow {{
            0%, 100% {{ opacity: 0.8; }}
            50% {{ opacity: 1; }}
        }}

        @keyframes pulse {{
            0% {{ transform: scale(1); }}
            50% {{ transform: scale(1.05); }}
            100% {{ transform: scale(1); }}
        }}

        @keyframes shake {{
            0%, 100% {{ transform: translateX(0); }}
            25% {{ transform: translateX(-2px); }}
            75% {{ transform: translateX(2px); }}
        }}

        .widget-tile {{
            transition: opacity 0.1s ease-in-out;
        }}

        .widget {{
            cursor: pointer;
            transition: transform 0.15s ease-in-out;
        }}

        .widget:hover {{
            transform: translateY(-2px);
            z-index: 10;
        }}

        .widget:active {{
            transform: translateY(0);
        }}

        /* Enhanced modal animations */
        .modal-overlay {{
            backdrop-filter: blur(8px);
            transition: opacity 0.3s ease-in-out;
        }}

        .modal-content {{
            animation: modalSlideIn 0.3s ease-out;
            transition: transform 0.2s ease-in-out;
        }}

        @keyframes modalSlideIn {{
            from {{
                opacity: 0;
                transform: translate(-50%, -45%) scale(0.9);
            }}
            to {{
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }}
        }}

        .modal-content:hover {{
            transform: translate(-50%, -50%) scale(1.02);
        }}

        /* Discovery animations */
        .discovery-popup {{
            animation: discoveryBounce 0.6s ease-out;
        }}

        @keyframes discoveryBounce {{
            0% {{
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }}
            50% {{
                transform: translate(-50%, -50%) scale(1.1);
            }}
            100% {{
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }}
        }}

        /* Enhanced loading states */
        .widget-loading {{
            position: relative;
            overflow: hidden;
        }}

        .widget-loading::after {{
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: loadingShimmer 1.5s infinite;
        }}

        @keyframes loadingShimmer {{
            0% {{ left: -100%; }}
            100% {{ left: 100%; }}
        }}

        /* Interactive feedback */
        .interactive-feedback {{
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, transparent 70%);
            animation: ripple 0.6s ease-out;
        }}

        @keyframes ripple {{
            from {{
                width: 0;
                height: 0;
                opacity: 1;
            }}
            to {{
                width: 100px;
                height: 100px;
                opacity: 0;
            }}
        }}
    </style>
</head>
<body>
    <!-- Loading State -->
    <div class="loading" id="loading">Loading World...</div>

    <!-- Main World Container -->
    <div class="world-container" id="worldContainer" style="display: none;">
        <div class="locations-wrapper" id="locationsWrapper">
            <!-- Locations will be dynamically generated here -->
        </div>
    </div>

    <!-- Floor Navigation GUI -->
    <div class="floor-navigation" id="floorNavigation" style="display: none;">
        <div class="floor-title">FLOORS</div>
        <div id="floorButtons">
            <!-- Floor buttons will be generated here -->
        </div>
    </div>

    <!-- Audio Toggle -->
    <div class="audio-toggle" id="audioToggle">🔊 SOUND</div>

    <!-- Modal System -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal-container">
            <div class="modal-header">
                <span id="modalTitle">Title</span>
                <button class="modal-close" id="modalClose">✕</button>
            </div>
            <div class="modal-content" id="modalContent">
                <!-- Content will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Dark Souls Location Discovery -->
    <div class="location-discovery" id="locationDiscovery">
        <div class="discovery-text">
            <div class="location-name" id="discoveryLocationName">LOCATION</div>
            <div class="location-subtitle">Location Discovered</div>
        </div>
    </div>

    <script>
        // ============================================
        // TILE SYSTEM
        // ============================================

        class TileManager {
            constructor(worldManager) {
                this.worldManager = worldManager;
                this.assetLoader = worldManager.assetLoader;
                this.tiles = new Map(); // locationId -> tile states
                this.currentLocation = null;
                this.tilesPath = 'static/world/';
            }

            async loadTilesForLocation(location) {
                if (!location.tiles) {
                    console.warn(`No tiles defined for location: ${location.id}`);
                    return;
                }

                const tileStates = {
                    idle: null,
                    hover: null,
                    click: null
                };

                // Load each tile state
                for (const [state, tilePath] of Object.entries(location.tiles)) {
                    try {
                        const tileUrl = `${this.tilesPath}${tilePath}`;
                        const tile = await this.assetLoader.loadAsset(tileUrl);
                        tileStates[state] = tile;
                    } catch (error) {
                        console.error(`Failed to load tile ${state} for location ${location.id}:`, error);
                    }
                }

                this.tiles.set(location.id, tileStates);
                console.log(`Loaded tiles for location: ${location.id}`);
            }

            async preloadLocationTiles(location) {
                if (location && location.tiles) {
                    await this.loadTilesForLocation(location);
                }
            }

            setTile(locationId, state, targetElement = null) {
                const tileStates = this.tiles.get(locationId);
                if (!tileStates) {
                    console.warn(`No tiles loaded for location: ${locationId}`);
                    return false;
                }

                const tile = tileStates[state];
                if (!tile) {
                    console.warn(`No ${state} tile found for location: ${locationId}`);
                    return false;
                }

                // If target element provided, use it; otherwise try to find main background
                const element = targetElement || document.getElementById('main-background') ||
                              document.querySelector('.modal-image') ||
                              document.querySelector('.location-modal img');

                if (element) {
                    element.src = tile.src;
                    return true;
                }

                return false;
            }

            setLocationTile(locationId, state) {
                // Set tile for a location container in the main view
                const container = document.querySelector(`.location-container[data-location-id="${locationId}"]`);
                if (container && this.tiles.has(locationId)) {
                    const tileStates = this.tiles.get(locationId);
                    const tile = tileStates[state];
                    if (tile) {
                        container.style.backgroundImage = `url('${tile.src}')`;
                        container.dataset.currentTile = state;
                        return true;
                    }
                }
                return false;
            }

            getCurrentTile(locationId) {
                const tileStates = this.tiles.get(locationId);
                return tileStates || null;
            }

            isTileLoaded(locationId) {
                return this.tiles.has(locationId);
            }

            unloadTiles(locationId) {
                this.tiles.delete(locationId);
                console.log(`Unloaded tiles for location: ${locationId}`);
            }

            clearAllTiles() {
                this.tiles.clear();
                this.currentLocation = null;
                console.log('Cleared all tiles from memory');
            }

            async preloadAllTiles(locations) {
                console.log('Preloading tiles for all locations...');
                const loadPromises = locations.map(location =>
                    this.preloadLocationTiles(location)
                );

                try {
                    await Promise.all(loadPromises);
                    console.log('All tiles preloaded successfully');
                } catch (error) {
                    console.error('Error preloading tiles:', error);
                }
            }

            getTilesInfo() {
                const info = {};
                for (const [locationId, tileStates] of this.tiles.entries()) {
                    info[locationId] = {
                        loaded: true,
                        states: {
                            idle: !!tileStates.idle,
                            hover: !!tileStates.hover,
                            click: !!tileStates.click
                        }
                    };
                }
                return info;
            }
        }

        // ============================================
        // PROMPT SYSTEM
        // ============================================

        class PromptManager {
            constructor(worldManager) {
                this.worldManager = worldManager;
                this.widgetPromptTemplates = new Map();
                this.locationPromptCache = new Map();
                this.initializePromptTemplates();
            }

            initializePromptTemplates() {
                // Initialize widget-specific prompt templates
                this.widgetPromptTemplates.set('time', {
                    base: 'kawaii anime wall clock showing current time',
                    idle: 'pink analog wall clock with cute design, showing current time peacefully',
                    hover: 'magical glowing pink wall clock with soft aura, sparkling with time magic',
                    click: 'enlarged magical clock face with floating time numbers and sparkles'
                });

                this.widgetPromptTemplates.set('status', {
                    base: 'kawaii status indicator plant',
                    idle: 'small cute cactus in pink pot with happy face, peaceful and calm',
                    hover: 'happy cactus slightly larger with joyful expression, glowing gently',
                    click: 'blooming cactus with beautiful pink flower, magical transformation moment'
                });

                this.widgetPromptTemplates.set('changelog', {
                    base: 'kawaii changelog book',
                    idle: 'cute magical book with version number on spine, closed peacefully',
                    hover: 'glowing spellbook with soft magical aura, version visible on cover',
                    click: 'open book with floating changelog text and magical sparkles around pages'
                });

                this.widgetPromptTemplates.set('link', {
                    base: 'kawaii link poster',
                    idle: 'retro anime poster on wall, peaceful and decorative',
                    hover: 'magical glowing poster with sparkling edges, drawing attention',
                    click: 'animated poster with pulsing effects and magical gateway energy'
                });

                this.widgetPromptTemplates.set('story', {
                    base: 'kawaii story element',
                    idle: 'peaceful story element, decorative and mysterious',
                    hover: 'glowing magical artifact with soft aura, hinting at adventure',
                    click: 'activated magical element with floating story text and sparkles'
                });

                this.widgetPromptTemplates.set('music', {
                    base: 'kawaii music player',
                    idle: 'vinyl record or music device, peaceful and decorative',
                    hover: 'glowing music element with sound waves and soft aura',
                    click: 'activated music player with floating notes and magical sound effects'
                });

                this.widgetPromptTemplates.set('online', {
                    base: 'kawaii online status indicator',
                    idle: 'small online status light, peaceful and stable',
                    hover: 'glowing online indicator with connection waves',
                    click: 'expanded online status with network effects and magical connections'
                });

                this.widgetPromptTemplates.set('version', {
                    base: 'kawaii version display',
                    idle: 'version number display, clean and peaceful',
                    hover: 'glowing version text with magical sparkle effects',
                    click: 'expanded version information with magical presentation'
                });

                this.widgetPromptTemplates.set('hash', {
                    base: 'kawaii hash display',
                    idle: 'hash identifier, technical but cute design',
                    hover: 'glowing hash with magical data flow effects',
                    click: 'expanded hash display with magical data visualization'
                });
            }

            generateWidgetPrompt(widget, state = 'idle') {
                const template = this.widgetPromptTemplates.get(widget.type);
                if (!template) {
                    console.warn(`No prompt template for widget type: ${widget.type}`);
                    return widget.description || '';
                }

                const statePrompt = template[state] || template.idle || template.base;
                const position = widget.position;
                const size = widget.size;

                // Add position and size context to the prompt
                const positionedPrompt = `${statePrompt}, positioned at (${position.x}, ${position.y}), size ${size.width}x${size.height}px`;

                return positionedPrompt;
            }

            generateLocationPrompt(location, state = 'idle') {
                // Check cache first
                const cacheKey = `${location.id}-${state}`;
                if (this.locationPromptCache.has(cacheKey)) {
                    return this.locationPromptCache.get(cacheKey);
                }

                let basePrompt = `kawaii anime room interior, ${location.name}, peaceful and cozy atmosphere`;

                // Add room-specific details
                if (location.description) {
                    basePrompt += `, ${location.description}`;
                }

                // Add widget descriptions for this state
                if (location.widgets) {
                    const widgetPrompts = location.widgets.map(widget => {
                        const widgetPrompt = this.generateWidgetPrompt(widget, state);
                        return `with ${widgetPrompt}`;
                    });

                    basePrompt += ', ' + widgetPrompts.join(', ');
                }

                // Add state-specific modifications
                const stateModifiers = {
                    idle: 'peaceful, calm, soft lighting, anime art style, high quality',
                    hover: 'magical glowing atmosphere, soft auras, sparkling effects, wonder and curiosity',
                    click: 'magical transformation moment, dynamic energy, sparkles and magical effects, excitement'
                };

                basePrompt += `, ${stateModifiers[state] || stateModifiers.idle}`;

                // Add quality and style modifiers
                basePrompt += ', masterpiece, best quality, detailed, beautiful anime art, digital painting';

                // Cache the result
                this.locationPromptCache.set(cacheKey, basePrompt);

                return basePrompt;
            }

            generateWidgetSpecificPrompt(widget, state = 'idle') {
                // Generate a prompt focused specifically on one widget for tile generation
                const location = this.findLocationByWidget(widget.id);
                if (!location) {
                    return this.generateWidgetPrompt(widget, state);
                }

                // Create a prompt that focuses on the specific widget while maintaining room context
                const basePrompt = this.generateLocationPrompt(location, state);
                const focusedPrompt = `${basePrompt}, focus on ${widget.name} (${widget.type}) with detailed interaction effects`;

                return focusedPrompt;
            }

            findLocationByWidget(widgetId) {
                if (!this.worldManager.locations) return null;

                return this.worldManager.locations.find(location => {
                    return location.widgets && location.widgets.some(widget => widget.id === widgetId);
                });
            }

            concatenatePrompts(basePrompt, ...additionalPrompts) {
                // Intelligently concatenate multiple prompts
                const allPrompts = [basePrompt, ...additionalPrompts].filter(p => p && p.trim());

                if (allPrompts.length === 0) return '';
                if (allPrompts.length === 1) return allPrompts[0];

                // Merge prompts while avoiding repetition
                let mergedPrompt = allPrompts[0];
                const usedWords = new Set(allPrompts[0].toLowerCase().split(/\s+/));

                for (let i = 1; i < allPrompts.length; i++) {
                    const prompt = allPrompts[i];
                    const words = prompt.split(/\s+/);
                    const newWords = words.filter(word =>
                        word.length > 2 && !usedWords.has(word.toLowerCase())
                    );

                    if (newWords.length > 0) {
                        mergedPrompt += ', ' + newWords.join(' ');
                        newWords.forEach(word => usedWords.add(word.toLowerCase()));
                    }
                }

                return mergedPrompt;
            }

            clearPromptCache() {
                this.locationPromptCache.clear();
                console.log('Prompt cache cleared');
            }

            getPromptCacheInfo() {
                return {
                    size: this.locationPromptCache.size,
                    cachedKeys: Array.from(this.locationPromptCache.keys())
                };
            }
        }

        // ============================================
        // IMAGE COMPOSITION SYSTEM
        // ============================================

        class ImageCompositionManager {
            constructor(worldManager) {
                this.worldManager = worldManager;
                this.canvasCache = new Map();
                this.layerStack = [];
                this.compositionQueue = [];
                this.isProcessing = false;
                this.maxCanvasSize = 2048; // Maximum canvas size for performance
            }

            async createCompositeTile(location, state = 'idle', options = {}) {
                console.log(`🎨 Creating composite tile for ${location.name} - ${state}`);

                const cacheKey = `${location.id}-${state}-${JSON.stringify(options)}`;
                if (this.canvasCache.has(cacheKey)) {
                    console.log(`📋 Using cached composite: ${cacheKey}`);
                    return this.canvasCache.get(cacheKey);
                }

                try {
                    // Create offscreen canvas for composition
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    // Set canvas size (1024x1024 for high quality)
                    canvas.width = 1024;
                    canvas.height = 1024;

                    // Initialize layer stack
                    this.layerStack = [];

                    // Add base room layer
                    await this.addBaseRoomLayer(ctx, location, state);

                    // Add widget layers
                    if (location.widgets) {
                        for (const widget of location.widgets) {
                            await this.addWidgetLayer(ctx, widget, state, location);
                        }
                    }

                    // Add effect overlays based on state
                    await this.addStateEffects(ctx, state);

                    // Add lighting and atmosphere
                    await this.addLightingEffects(ctx, state);

                    // Convert canvas to blob and cache
                    const blob = await this.canvasToBlob(canvas);
                    const imageUrl = URL.createObjectURL(blob);

                    // Cache the result
                    this.canvasCache.set(cacheKey, imageUrl);

                    console.log(`✅ Composite tile created: ${cacheKey}`);
                    return imageUrl;

                } catch (error) {
                    console.error(`❌ Error creating composite tile: ${error.message}`);
                    return null;
                }
            }

            async addBaseRoomLayer(ctx, location, state) {
                console.log(`🏠 Adding base room layer for ${location.name}`);

                // Draw base room background
                const gradient = ctx.createLinearGradient(0, 0, ctx.canvas.width, ctx.canvas.height);

                // Color schemes based on state
                const stateColors = {
                    idle: ['#2a1a4a', '#1a0f2a', '#0f051a'], // Dark purple tones
                    hover: ['#3a2a5a', '#2a1f3a', '#1f0f2a'], // Slightly brighter purples
                    click: ['#4a3a6a', '#3a2f4a', '#2f1f3a']  // Even brighter with energy
                };

                const colors = stateColors[state] || stateColors.idle;
                colors.forEach((color, index) => {
                    gradient.addColorStop(index / (colors.length - 1), color);
                });

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                // Add room structure elements
                await this.drawRoomStructure(ctx, location, state);

                this.layerStack.push({
                    type: 'base',
                    name: 'room',
                    timestamp: Date.now()
                });
            }

            async drawRoomStructure(ctx, location, state) {
                // Draw basic room structure
                const centerX = ctx.canvas.width / 2;
                const centerY = ctx.canvas.height / 2;

                // Floor
                ctx.fillStyle = state === 'click' ? '#4a3a6a' : '#3a2a5a';
                ctx.fillRect(100, 700, 824, 224);

                // Back wall
                ctx.fillStyle = state === 'click' ? '#5a4a7a' : '#4a3a6a';
                ctx.fillRect(100, 200, 824, 500);

                // Add depth with lines
                ctx.strokeStyle = state === 'click' ? '#7a6a9a' : '#6a5a8a';
                ctx.lineWidth = 2;

                // Floor lines
                for (let i = 0; i < 5; i++) {
                    const y = 700 + (i * 56);
                    ctx.beginPath();
                    ctx.moveTo(100, y);
                    ctx.lineTo(924, y);
                    ctx.stroke();
                }

                // Wall sections
                for (let i = 0; i < 4; i++) {
                    const x = 100 + (i * 206);
                    ctx.beginPath();
                    ctx.moveTo(x, 200);
                    ctx.lineTo(x, 700);
                    ctx.stroke();
                }

                // Add windows
                await this.drawWindows(ctx, state);

                // Add door
                await this.drawDoor(ctx, state);
            }

            async drawWindows(ctx, state) {
                // Draw windows with state-based effects
                const windowPositions = [
                    { x: 200, y: 300, width: 120, height: 150 },
                    { x: 700, y: 300, width: 120, height: 150 }
                ];

                windowPositions.forEach(window => {
                    // Window frame
                    ctx.fillStyle = state === 'click' ? '#8a7aaa' : '#7a6a9a';
                    ctx.fillRect(window.x, window.y, window.width, window.height);

                    // Glass
                    const glassGradient = ctx.createLinearGradient(
                        window.x, window.y,
                        window.x + window.width, window.y + window.height
                    );

                    if (state === 'hover') {
                        glassGradient.addColorStop(0, 'rgba(135, 206, 250, 0.3)'); // Sky blue with glow
                        glassGradient.addColorStop(1, 'rgba(135, 206, 250, 0.1)');
                    } else if (state === 'click') {
                        glassGradient.addColorStop(0, 'rgba(255, 215, 0, 0.4)'); // Golden with energy
                        glassGradient.addColorStop(1, 'rgba(255, 215, 0, 0.2)');
                    } else {
                        glassGradient.addColorStop(0, 'rgba(135, 206, 250, 0.2)'); // Normal sky blue
                        glassGradient.addColorStop(1, 'rgba(135, 206, 250, 0.05)');
                    }

                    ctx.fillStyle = glassGradient;
                    ctx.fillRect(window.x + 5, window.y + 5, window.width - 10, window.height - 10);

                    // Window cross
                    ctx.strokeStyle = state === 'click' ? '#9a8aba' : '#8a7aaa';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(window.x + window.width / 2, window.y);
                    ctx.lineTo(window.x + window.width / 2, window.y + window.height);
                    ctx.moveTo(window.x, window.y + window.height / 2);
                    ctx.lineTo(window.x + window.width, window.y + window.height / 2);
                    ctx.stroke();
                });
            }

            async drawDoor(ctx, state) {
                // Draw room door
                const door = {
                    x: 450,
                    y: 500,
                    width: 100,
                    height: 200
                };

                // Door frame
                ctx.fillStyle = state === 'click' ? '#7a6aaa' : '#6a5a9a';
                ctx.fillRect(door.x, door.y, door.width, door.height);

                // Door details
                ctx.strokeStyle = state === 'click' ? '#8a7aba' : '#7a6aaa';
                ctx.lineWidth = 2;
                ctx.strokeRect(door.x + 5, door.y + 5, door.width - 10, door.height - 10);

                // Door knob
                ctx.fillStyle = state === 'click' ? '#ffd700' : '#daa520';
                ctx.beginPath();
                ctx.arc(door.x + door.width - 20, door.y + door.height / 2, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            async addWidgetLayer(ctx, widget, state, location) {
                console.log(`🔧 Adding widget layer: ${widget.name} (${widget.type})`);

                // Scale widget positions from original (1024px) to canvas size
                const scaleX = ctx.canvas.width / 1024;
                const scaleY = ctx.canvas.height / 1024;

                const x = widget.position.x * scaleX;
                const y = widget.position.y * scaleY;
                const width = widget.size.width * scaleX;
                const height = widget.size.height * scaleY;

                // Draw widget based on type and state
                await this.drawWidget(ctx, widget, x, y, width, height, state);

                this.layerStack.push({
                    type: 'widget',
                    widgetId: widget.id,
                    widgetType: widget.type,
                    timestamp: Date.now()
                });
            }

            async drawWidget(ctx, widget, x, y, width, height, state) {
                // Draw different widget types
                switch (widget.type) {
                    case 'time':
                        await this.drawClockWidget(ctx, x, y, width, height, state);
                        break;
                    case 'status':
                        await this.drawStatusWidget(ctx, x, y, width, height, state);
                        break;
                    case 'changelog':
                        await this.drawBookWidget(ctx, x, y, width, height, state);
                        break;
                    case 'link':
                        await this.drawPosterWidget(ctx, x, y, width, height, state);
                        break;
                    case 'story':
                        await this.drawArtifactWidget(ctx, x, y, width, height, state);
                        break;
                    case 'music':
                        await this.drawMusicWidget(ctx, x, y, width, height, state);
                        break;
                    default:
                        await this.drawGenericWidget(ctx, x, y, width, height, state);
                }
            }

            async drawClockWidget(ctx, x, y, width, height, state) {
                // Draw analog clock
                const centerX = x + width / 2;
                const centerY = y + height / 2;
                const radius = Math.min(width, height) / 2 - 5;

                // Clock face
                ctx.fillStyle = state === 'click' ? '#ffb3d9' : '#ff69b4';
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();

                // Clock border
                ctx.strokeStyle = state === 'click' ? '#ff1493' : '#c71585';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Clock numbers (simplified)
                ctx.fillStyle = '#ffffff';
                ctx.font = `${radius / 4}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                for (let i = 1; i <= 12; i++) {
                    const angle = (i - 3) * (Math.PI * 2 / 12);
                    const numX = centerX + Math.cos(angle) * (radius * 0.7);
                    const numY = centerY + Math.sin(angle) * (radius * 0.7);
                    ctx.fillText(i.toString(), numX, numY);
                }

                // Clock hands (showing current time)
                const now = new Date();
                const hours = now.getHours() % 12;
                const minutes = now.getMinutes();
                const seconds = now.getSeconds();

                // Hour hand
                const hourAngle = ((hours + minutes / 60) - 3) * (Math.PI * 2 / 12);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(hourAngle) * (radius * 0.5),
                    centerY + Math.sin(hourAngle) * (radius * 0.5)
                );
                ctx.stroke();

                // Minute hand
                const minuteAngle = ((minutes + seconds / 60) - 15) * (Math.PI * 2 / 60);
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(minuteAngle) * (radius * 0.7),
                    centerY + Math.sin(minuteAngle) * (radius * 0.7)
                );
                ctx.stroke();

                // Second hand (if in click state for more detail)
                if (state === 'click') {
                    const secondAngle = (seconds - 15) * (Math.PI * 2 / 60);
                    ctx.strokeStyle = '#ff1493';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(
                        centerX + Math.cos(secondAngle) * (radius * 0.8),
                        centerY + Math.sin(secondAngle) * (radius * 0.8)
                    );
                    ctx.stroke();
                }

                // Center dot
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            async drawStatusWidget(ctx, x, y, width, height, state) {
                // Draw cactus plant
                const potWidth = width * 0.6;
                const potHeight = height * 0.3;
                const potX = x + (width - potWidth) / 2;
                const potY = y + height - potHeight;

                // Flower pot
                ctx.fillStyle = '#ff69b4'; // Pink pot
                ctx.fillRect(potX, potY, potWidth, potHeight);
                ctx.strokeStyle = '#c71585';
                ctx.lineWidth = 2;
                ctx.strokeRect(potX, potY, potWidth, potHeight);

                // Cactus body
                const cactusWidth = width * 0.4;
                const cactusHeight = height * 0.5;
                const cactusX = x + (width - cactusWidth) / 2;
                const cactusY = potY - cactusHeight;

                ctx.fillStyle = '#90ee90'; // Light green
                ctx.fillRect(cactusX, cactusY, cactusWidth, cactusHeight);
                ctx.strokeStyle = '#228b22';
                ctx.strokeRect(cactusX, cactusY, cactusWidth, cactusHeight);

                // Cactus face (cute)
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(cactusX + cactusWidth * 0.3, cactusY + cactusHeight * 0.3, 2, 0, Math.PI * 2);
                ctx.arc(cactusX + cactusWidth * 0.7, cactusY + cactusHeight * 0.3, 2, 0, Math.PI * 2);
                ctx.fill();

                // Smile
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(cactusX + cactusWidth / 2, cactusY + cactusHeight * 0.5, cactusWidth * 0.2, 0, Math.PI);
                ctx.stroke();

                // Flower (if in click state)
                if (state === 'click') {
                    const flowerX = cactusX + cactusWidth / 2;
                    const flowerY = cactusY - 10;
                    const petalRadius = 8;

                    // Flower petals
                    ctx.fillStyle = '#ffb6c1'; // Light pink
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * Math.PI * 2) / 5;
                        const petalX = flowerX + Math.cos(angle) * petalRadius;
                        const petalY = flowerY + Math.sin(angle) * petalRadius;
                        ctx.beginPath();
                        ctx.arc(petalX, petalY, petalRadius * 0.7, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Flower center
                    ctx.fillStyle = '#ffd700'; // Gold
                    ctx.beginPath();
                    ctx.arc(flowerX, flowerY, petalRadius * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            async drawBookWidget(ctx, x, y, width, height, state) {
                // Draw book
                const bookWidth = width * 0.8;
                const bookHeight = height * 0.9;
                const bookX = x + (width - bookWidth) / 2;
                const bookY = y + (height - bookHeight) / 2;

                // Book cover
                ctx.fillStyle = state === 'click' ? '#9370db' : '#8a2be2'; // Purple
                ctx.fillRect(bookX, bookY, bookWidth, bookHeight);
                ctx.strokeStyle = state === 'click' ? '#ffd700' : '#daa520'; // Gold trim
                ctx.lineWidth = 2;
                ctx.strokeRect(bookX, bookY, bookWidth, bookHeight);

                // Book spine
                ctx.fillStyle = state === 'click' ? '#7b68ee' : '#6a5acd';
                ctx.fillRect(bookX, bookY, bookWidth * 0.15, bookHeight);

                // Book title (simplified "v0.1.0")
                ctx.fillStyle = '#ffffff';
                ctx.font = `${bookHeight / 8}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('v0.1.0', bookX + bookWidth / 2, bookY + bookHeight / 2);

                // Magical glow effect in hover/click states
                if (state === 'hover' || state === 'click') {
                    const gradient = ctx.createRadialGradient(
                        bookX + bookWidth / 2, bookY + bookHeight / 2, 0,
                        bookX + bookWidth / 2, bookY + bookHeight / 2, Math.max(bookWidth, bookHeight)
                    );
                    gradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                    gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(bookX - 20, bookY - 20, bookWidth + 40, bookHeight + 40);
                }
            }

            async drawPosterWidget(ctx, x, y, width, height, state) {
                // Draw poster frame
                const frameWidth = width * 0.9;
                const frameHeight = height * 0.9;
                const frameX = x + (width - frameWidth) / 2;
                const frameY = y + (height - frameHeight) / 2;

                // Poster background
                const gradient = ctx.createLinearGradient(frameX, frameY, frameX + frameWidth, frameY + frameHeight);
                if (state === 'click') {
                    gradient.addColorStop(0, '#ff6b6b');
                    gradient.addColorStop(1, '#4ecdc4');
                } else {
                    gradient.addColorStop(0, '#667eea');
                    gradient.addColorStop(1, '#764ba2');
                }
                ctx.fillStyle = gradient;
                ctx.fillRect(frameX, frameY, frameWidth, frameHeight);

                // Poster border
                ctx.strokeStyle = state === 'click' ? '#ffd700' : '#c0c0c0';
                ctx.lineWidth = 3;
                ctx.strokeRect(frameX, frameY, frameWidth, frameHeight);

                // "The Edge Story" text (simplified)
                ctx.fillStyle = '#ffffff';
                ctx.font = `${frameHeight / 8}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('THE EDGE', frameX + frameWidth / 2, frameY + frameHeight * 0.4);
                ctx.fillText('STORY', frameX + frameWidth / 2, frameY + frameHeight * 0.6);

                // Sparkle effects in hover/click states
                if (state === 'hover' || state === 'click') {
                    for (let i = 0; i < 5; i++) {
                        const sparkleX = frameX + Math.random() * frameWidth;
                        const sparkleY = frameY + Math.random() * frameHeight;
                        const sparkleSize = Math.random() * 3 + 1;

                        ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.8 + 0.2})`;
                        ctx.beginPath();
                        ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            async drawArtifactWidget(ctx, x, y, width, height, state) {
                // Draw mysterious artifact
                const artifactSize = Math.min(width, height) * 0.7;
                const artifactX = x + (width - artifactSize) / 2;
                const artifactY = y + (height - artifactSize) / 2;

                // Artifact glow
                if (state === 'hover' || state === 'click') {
                    const glowGradient = ctx.createRadialGradient(
                        artifactX + artifactSize / 2, artifactY + artifactSize / 2, 0,
                        artifactX + artifactSize / 2, artifactY + artifactSize / 2, artifactSize
                    );
                    glowGradient.addColorStop(0, 'rgba(138, 43, 226, 0.4)');
                    glowGradient.addColorStop(1, 'rgba(138, 43, 226, 0)');
                    ctx.fillStyle = glowGradient;
                    ctx.fillRect(artifactX - 20, artifactY - 20, artifactSize + 40, artifactSize + 40);
                }

                // Main artifact (crystal shape)
                ctx.fillStyle = state === 'click' ? '#9370db' : '#8a2be2';
                ctx.beginPath();
                ctx.moveTo(artifactX + artifactSize / 2, artifactY);
                ctx.lineTo(artifactX + artifactSize, artifactY + artifactSize * 0.7);
                ctx.lineTo(artifactX + artifactSize * 0.7, artifactY + artifactSize);
                ctx.lineTo(artifactX + artifactSize * 0.3, artifactY + artifactSize);
                ctx.lineTo(artifactX, artifactY + artifactSize * 0.7);
                ctx.closePath();
                ctx.fill();

                // Crystal facets
                ctx.strokeStyle = state === 'click' ? '#dda0dd' : '#ba55d3';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(artifactX + artifactSize / 2, artifactY);
                ctx.lineTo(artifactX + artifactSize * 0.7, artifactY + artifactSize);
                ctx.moveTo(artifactX + artifactSize / 2, artifactY);
                ctx.lineTo(artifactX + artifactSize * 0.3, artifactY + artifactSize);
                ctx.stroke();
            }

            async drawMusicWidget(ctx, x, y, width, height, state) {
                // Draw vinyl record
                const recordRadius = Math.min(width, height) / 2 - 5;
                const centerX = x + width / 2;
                const centerY = y + height / 2;

                // Record black
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(centerX, centerY, recordRadius, 0, Math.PI * 2);
                ctx.fill();

                // Record grooves (circles)
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 1;
                for (let i = 1; i < 5; i++) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, recordRadius * (i / 5), 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Center label
                const labelRadius = recordRadius * 0.3;
                ctx.fillStyle = state === 'click' ? '#ff6b6b' : '#ff69b4';
                ctx.beginPath();
                ctx.arc(centerX, centerY, labelRadius, 0, Math.PI * 2);
                ctx.fill();

                // Center hole
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
                ctx.fill();

                // Musical notes in hover/click state
                if (state === 'hover' || state === 'click') {
                    ctx.fillStyle = `rgba(255, 255, 255, ${state === 'click' ? 0.8 : 0.5})`;
                    ctx.font = '16px Arial';
                    ctx.fillText('♪', centerX - 20, centerY - recordRadius - 10);
                    ctx.fillText('♫', centerX + 20, centerY - recordRadius - 10);
                }
            }

            async drawGenericWidget(ctx, x, y, width, height, state) {
                // Draw a generic widget placeholder
                ctx.fillStyle = state === 'click' ? '#7b68ee' : '#6a5acd';
                ctx.fillRect(x + 5, y + 5, width - 10, height - 10);
                ctx.strokeStyle = state === 'click' ? '#9370db' : '#8a2be2';
                ctx.lineWidth = 2;
                ctx.strokeRect(x + 5, y + 5, width - 10, height - 10);

                // Question mark
                ctx.fillStyle = '#ffffff';
                ctx.font = `${width / 2}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('?', x + width / 2, y + height / 2);
            }

            async addStateEffects(ctx, state) {
                console.log(`✨ Adding state effects for: ${state}`);

                if (state === 'hover') {
                    // Add subtle glow effect
                    const glowGradient = ctx.createRadialGradient(
                        ctx.canvas.width / 2, ctx.canvas.height / 2, 0,
                        ctx.canvas.width / 2, ctx.canvas.height / 2, ctx.canvas.width / 2
                    );
                    glowGradient.addColorStop(0, 'rgba(255, 215, 0, 0.1)');
                    glowGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    ctx.fillStyle = glowGradient;
                    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                } else if (state === 'click') {
                    // Add strong magical effect
                    const effectGradient = ctx.createRadialGradient(
                        ctx.canvas.width / 2, ctx.canvas.height / 2, 0,
                        ctx.canvas.width / 2, ctx.canvas.height / 2, ctx.canvas.width / 2
                    );
                    effectGradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                    effectGradient.addColorStop(0.5, 'rgba(138, 43, 226, 0.2)');
                    effectGradient.addColorStop(1, 'rgba(138, 43, 226, 0)');
                    ctx.fillStyle = effectGradient;
                    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                    // Add sparkles
                    for (let i = 0; i < 20; i++) {
                        const sparkleX = Math.random() * ctx.canvas.width;
                        const sparkleY = Math.random() * ctx.canvas.height;
                        const sparkleSize = Math.random() * 4 + 1;
                        const opacity = Math.random() * 0.8 + 0.2;

                        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                        ctx.beginPath();
                        ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                this.layerStack.push({
                    type: 'effects',
                    state: state,
                    timestamp: Date.now()
                });
            }

            async addLightingEffects(ctx, state) {
                console.log(`💡 Adding lighting effects for: ${state}`);

                // Add ambient lighting
                const lightingGradient = ctx.createLinearGradient(0, 0, ctx.canvas.width, ctx.canvas.height);

                if (state === 'idle') {
                    lightingGradient.addColorStop(0, 'rgba(255, 255, 255, 0.05)');
                    lightingGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                } else if (state === 'hover') {
                    lightingGradient.addColorStop(0, 'rgba(255, 215, 0, 0.1)');
                    lightingGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                } else if (state === 'click') {
                    lightingGradient.addColorStop(0, 'rgba(255, 215, 0, 0.2)');
                    lightingGradient.addColorStop(0.5, 'rgba(138, 43, 226, 0.1)');
                    lightingGradient.addColorStop(1, 'rgba(138, 43, 226, 0)');
                }

                ctx.fillStyle = lightingGradient;
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                this.layerStack.push({
                    type: 'lighting',
                    state: state,
                    timestamp: Date.now()
                });
            }

            async canvasToBlob(canvas) {
                return new Promise((resolve) => {
                    canvas.toBlob((blob) => {
                        resolve(blob);
                    }, 'image/png');
                });
            }

            clearCache() {
                this.canvasCache.clear();
                console.log('🗑️ Image composition cache cleared');
            }

            getCacheInfo() {
                return {
                    size: this.canvasCache.size,
                    keys: Array.from(this.canvasCache.keys()),
                    layerStack: this.layerStack
                };
            }

            async pregenerateLocationTiles(location) {
                console.log(`🎨 Pregenerating all tile states for ${location.name}`);

                const states = ['idle', 'hover', 'click'];
                const results = {};

                for (const state of states) {
                    try {
                        const imageUrl = await this.createCompositeTile(location, state);
                        results[state] = imageUrl;
                        console.log(`✅ Generated ${state} tile for ${location.name}`);
                    } catch (error) {
                        console.error(`❌ Failed to generate ${state} tile: ${error.message}`);
                        results[state] = null;
                    }
                }

                return results;
            }
        }

        // ============================================
        // AUDIO SYSTEM
        // ============================================

        class AudioManager {
            constructor() {
                this.context = null;
                this.sounds = {};
                this.music = null;
                this.backgroundMusic = null;
                this.enabled = true;
                this.initialized = false;
                this.audioToggle = document.getElementById('audioToggle');

                this.initAudio();
                this.setupEventListeners();
            }

            initAudio() {
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                    this.initialized = true;
                } catch (e) {
                    console.warn('Audio not supported:', e);
                    this.enabled = false;
                }
            }

            setupEventListeners() {
                this.audioToggle.addEventListener('click', () => this.toggleAudio());

                // Initialize audio on first user interaction
                document.addEventListener('click', () => this.initAudio(), { once: true });
                document.addEventListener('touchstart', () => this.initAudio(), { once: true });
            }

            toggleAudio() {
                this.enabled = !this.enabled;
                this.audioToggle.textContent = this.enabled ? '🔊 SOUND' : '🔇 MUTED';
                this.audioToggle.classList.toggle('muted', !this.enabled);

                if (!this.enabled && this.music) {
                    this.stopMusic();
                }
            }

            async loadSound(name, url) {
                if (!this.initialized) return;

                try {
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await this.context.decodeAudioData(arrayBuffer);
                    this.sounds[name] = audioBuffer;
                } catch (e) {
                    console.warn(`Failed to load sound ${name}:`, e);
                }
            }

            generateSound(name, frequency, duration, type = 'sine') {
                if (!this.initialized) return;

                try {
                    const sampleRate = this.context.sampleRate;
                    const numSamples = sampleRate * duration;
                    const buffer = this.context.createBuffer(1, numSamples, sampleRate);
                    const data = buffer.getChannelData(0);

                    // Generate retro game style sounds
                    for (let i = 0; i < numSamples; i++) {
                        const t = i / sampleRate;
                        let sample = 0;

                        switch (name) {
                            case 'hover':
                                // Gentle chime-like sound
                                sample = Math.sin(2 * Math.PI * 1200 * t) * Math.exp(-t * 8) * 0.3;
                                sample += Math.sin(2 * Math.PI * 2400 * t) * Math.exp(-t * 12) * 0.2;
                                break;
                            case 'click':
                                // Retro game click sound
                                sample = Math.sin(2 * Math.PI * 800 * t) * 0.3;
                                sample += Math.sin(2 * Math.PI * 400 * t) * 0.2;
                                sample *= Math.exp(-t * 15);
                                break;
                            case 'discovery':
                                // Dark Souls discovery sound
                                sample = Math.sin(2 * Math.PI * 440 * t) * 0.4;
                                sample += Math.sin(2 * Math.PI * 880 * t) * 0.3;
                                sample *= Math.sin(2 * Math.PI * 220 * t) * 0.2;
                                break;
                            case 'quest-complete':
                                // WoW quest complete sound (simplified)
                                sample = Math.sin(2 * Math.PI * 523 * t) * 0.5;
                                sample += Math.sin(2 * Math.PI * 659 * t) * 0.4;
                                sample += Math.sin(2 * Math.PI * 784 * t) * 0.3;
                                sample *= Math.sin(2 * Math.PI * 2 * t); // Envelope
                                break;
                            default:
                                // Default sine wave
                                sample = Math.sin(2 * Math.PI * frequency * t) * Math.exp(-t * 5);
                        }

                        data[i] = sample;
                    }

                    this.sounds[name] = buffer;
                    console.log(`✅ Generated retro sound: ${name}`);
                } catch (e) {
                    console.warn(`Failed to generate sound ${name}:`, e);
                }
            }

            async playBackgroundMusic() {
                if (!this.enabled || !this.initialized) return;

                try {
                    // Try to load external music file first
                    try {
                        const response = await fetch('eternal_study.wav');
                        if (response.ok) {
                            const arrayBuffer = await response.arrayBuffer();
                            const audioBuffer = await this.context.decodeAudioData(arrayBuffer);

                            const source = this.context.createBufferSource();
                            source.buffer = audioBuffer;
                            source.loop = true;

                            const gainNode = this.context.createGain();
                            gainNode.gain.value = 0.20; // Slightly higher volume for external music

                            source.connect(gainNode);
                            gainNode.connect(this.context.destination);
                            source.start(0);

                            this.musicSource = source;
                            console.log('🎵 Started external lofi music: "Eternal Study" by Lofi Fruits Music');
                            return;
                        }
                    } catch (externalError) {
                        console.warn('Failed to load external music, falling back to generated:', externalError);
                    }

                    // Fallback to procedural generation
                    this.backgroundMusic = this.generateLoFiMusic();
                    const source = this.context.createBufferSource();
                    source.buffer = this.backgroundMusic;
                    source.loop = true;

                    const gainNode = this.context.createGain();
                    gainNode.gain.value = 0.15; // Low volume for background

                    source.connect(gainNode);
                    gainNode.connect(this.context.destination);
                    source.start(0);

                    console.log('🎵 Started procedural lofi anime background music (fallback)');
                } catch (e) {
                    console.warn('Failed to play background music:', e);
                }
            }

            generateLoFiMusic() {
                if (!this.initialized) return null;

                try {
                    const sampleRate = this.context.sampleRate;
                    const duration = 60.0; // 60 seconds for longer, continuous listening
                    const numSamples = sampleRate * duration;
                    const buffer = this.context.createBuffer(2, numSamples, sampleRate); // Stereo for quality
                    const leftChannel = buffer.getChannelData(0);
                    const rightChannel = buffer.getChannelData(1);

                    // Sophisticated anime-inspired jazz chord progression
                    const chordProgression = [
                        { root: 261.63, third: 329.63, fifth: 392.00, seventh: 466.16 }, // Cmaj7
                        { root: 293.66, third: 369.99, fifth: 440.00, seventh: 523.25 }, // Dmin7
                        { root: 349.23, third: 440.00, fifth: 523.25, seventh: 587.33 }, // Fmaj7
                        { root: 392.00, third: 493.88, fifth: 587.33, seventh: 698.46 }, // G7
                        { root: 329.63, third: 415.30, fifth: 493.88, seventh: 587.33 }, // Emin7
                        { root: 246.94, third: 311.13, fifth: 369.99, seventh: 440.00 }, // Amin7
                        { root: 349.23, third: 440.00, fifth: 523.25, seventh: 392.00 }, // Fadd2
                        { root: 261.63, third: 329.63, fifth: 392.00, seventh: 466.16 }  // Cmaj7
                    ];

                    // Pentatonic melody notes for that authentic anime feel
                    const melodyNotes = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25];

                    for (let i = 0; i < numSamples; i++) {
                        const t = i / sampleRate;
                        let sample = 0;

                        // Change chord every 7.5 seconds for smooth progression
                        const chordIndex = Math.floor(t / 7.5) % chordProgression.length;
                        const chord = chordProgression[chordIndex];
                        const chordProgress = (t % 7.5) / 7.5;

                        // Generate rich jazz chord with 7th for sophisticated sound
                        // Root (f fundamental)
                        sample += Math.sin(2 * Math.PI * chord.root * t) * 0.10;

                        // Third
                        sample += Math.sin(2 * Math.PI * chord.third * t) * 0.08;

                        // Fifth
                        sample += Math.sin(2 * Math.PI * chord.fifth * t) * 0.06;

                        // Seventh (for that jazzy lofi feel)
                        if (chord.seventh) {
                            sample += Math.sin(2 * Math.PI * chord.seventh * t) * 0.05;
                        }

                        // Add octave doubling for warmth and fullness
                        sample += Math.sin(2 * Math.PI * chord.root * 2 * t) * 0.03;

                        // Gentle walking bass line
                        const bassFreq = chord.root / 2;
                        const bassPattern = Math.sin(2 * Math.PI * 2 * t); // Half-note walking pattern
                        if (bassPattern > 0.2) {
                            sample += Math.sin(2 * Math.PI * bassFreq * t) * 0.08;
                        }

                        // Subtle melody line using pentatonic scale
                        const melodyPosition = (t % 7.5) / 7.5;
                        const melodyIndex = Math.floor(melodyPosition * 8) % melodyNotes.length;
                        const melodyRhythm = Math.sin(2 * Math.PI * 8 * t);
                        if (melodyRhythm > 0.6) { // Play melody 20% of the time
                            const melodyFreq = melodyNotes[melodyIndex];
                            // Add envelope for natural note decay
                            const noteEnvelope = Math.exp(-((t % 0.5) * 4));
                            sample += Math.sin(2 * Math.PI * melodyFreq * t) * 0.04 * noteEnvelope;
                        }

                        // Retro game inspired percussion elements
                        // Kick drum on beats 1 and 3
                        const kickBeat = (t * 2) % 1 < 0.1 ? 1 : 0;
                        sample += kickBeat * Math.sin(2 * Math.PI * 60 * t) * 0.12 * Math.exp(-t * 30);

                        // Snare on beats 2 and 4
                        const snareBeat = ((t * 2) + 0.5) % 1 < 0.05 ? 1 : 0;
                        sample += snareBeat * (Math.random() - 0.5) * 0.08 * Math.exp(-t * 100);

                        // Hi-hat pattern (8th notes)
                        const hihatPattern = Math.sin(2 * Math.PI * 4 * t);
                        if (hihatPattern > 0.3) {
                            sample += (Math.random() - 0.5) * 0.015;
                        }

                        // High-quality vintage tape emulation for authentic lofi character
                        const tapeNoise = (Math.random() - 0.5) * 0.002;
                        const wowFlutter = Math.sin(2 * Math.PI * 0.1 * t) * 0.015 + Math.sin(2 * Math.PI * 3 * t) * 0.003;

                        // Apply gentle saturation for warmth
                        sample = Math.tanh(sample * 1.2) * 0.8;

                        sample += tapeNoise;
                        sample *= (1 + wowFlutter);

                        // Smooth ADSR envelope for natural chord transitions
                        let envelope = 1;
                        if (chordProgress < 0.15) {
                            envelope = chordProgress / 0.15; // Smooth attack
                        } else if (chordProgress > 0.85) {
                            envelope = (1 - chordProgress) / 0.15; // Smooth release
                        } else {
                            envelope = 1; // Sustain
                        }

                        // Apply overall volume with gentle limiting
                        sample = Math.tanh(sample) * envelope * 0.2;

                        // Create subtle stereo widening for space
                        const stereoWidth = 0.15;
                        const stereoDelay = Math.sin(2 * Math.PI * 0.5 * t) * 0.1;

                        leftChannel[i] = sample * (1 + stereoWidth) * (1 + stereoDelay);
                        rightChannel[i] = sample * (1 - stereoWidth) * (1 - stereoDelay);
                    }

                    console.log('🎵 Generated high-quality 60-second lofi anime background music');
                    return buffer;
                } catch (e) {
                    console.warn('Failed to generate lofi music:', e);
                    return null;
                }
            }

            playSound(name, volume = 1.0) {
                if (!this.enabled || !this.initialized || !this.sounds[name]) return;

                const source = this.context.createBufferSource();
                source.buffer = this.sounds[name];

                const gainNode = this.context.createGain();
                gainNode.gain.value = volume;

                source.connect(gainNode);
                gainNode.connect(this.context.destination);
                source.start(0);
            }

            async playMusic(url, loop = true) {
                if (!this.enabled) return;

                try {
                    this.stopMusic();
                    this.music = new Audio(url);
                    this.music.loop = loop;
                    this.music.volume = 0.3;
                    await this.music.play();
                } catch (e) {
                    console.warn('Music play failed:', e);
                }
            }

            stopMusic() {
                if (this.music) {
                    this.music.pause();
                    this.music = null;
                }
            }

            // Placeholder sound effects
            playHover() { this.playSound('hover', 0.3); }
            playClick() { this.playSound('click', 0.5); }
            playDiscovery() { this.playSound('discovery', 0.8); }
            playEasterEgg() { this.playSound('quest-complete', 0.9); }
        }

        // ============================================
        // WIDGET MANAGER
        // ============================================

        class WidgetManager {
            constructor(worldManager) {
                this.worldManager = worldManager;
                this.audioManager = worldManager.audioManager;
                this.widgets = new Map(); // widgetId -> widget instance
                this.widgetRegistry = {
                    'time': TimeWidget,
                    'status': StatusWidget,
                    'version': VersionWidget,
                    'hash': HashWidget,
                    'online': OnlineWidget,
                    'changelog': ChangelogWidget,
                    'link': LinkWidget,
                    'story': StoryWidget,
                    'music': MusicWidget
                };
            }

            createWidget(container, widget, location) {
                // Get widget class from registry
                const WidgetClass = this.widgetRegistry[widget.type] || BaseWidget;

                // Create widget instance
                const widgetInstance = new WidgetClass(widget, this.worldManager, location.id);
                this.widgets.set(widget.id, widgetInstance);

                // Create widget group for all tiles of this widget
                const widgetGroup = document.createElement('div');
                widgetGroup.className = 'widget-group';
                widgetGroup.dataset.widgetId = widget.id;
                widgetGroup.dataset.locationId = location.id;

                // Create interactive area
                const widgetArea = document.createElement('div');
                widgetArea.className = 'widget-area';
                widgetArea.style.left = `${widget.position.x}px`;
                widgetArea.style.top = `${widget.position.y}px`;
                widgetArea.style.width = `${widget.size.width}px`;
                widgetArea.style.height = `${widget.size.height}px`;
                widgetArea.dataset.widgetId = widget.id;
                widgetArea.dataset.widgetType = widget.type;
                widgetArea.dataset.locationId = location.id;

                // Add hover and click events
                widgetArea.addEventListener('mouseenter', () => {
                    this.handleWidgetHover(widget.id, true, location.id);
                    widgetInstance.onHover();
                });
                widgetArea.addEventListener('mouseleave', () => {
                    this.handleWidgetHover(widget.id, false, location.id);
                });
                widgetArea.addEventListener('mousedown', () => {
                    this.handleWidgetClick(widget.id, true, location.id);
                });
                widgetArea.addEventListener('mouseup', () => {
                    this.handleWidgetClick(widget.id, false, location.id);
                });
                widgetArea.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleWidgetClick(widget.id, true, location.id);
                });
                widgetArea.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleWidgetClick(widget.id, false, location.id);
                });

                container.appendChild(widgetGroup);
                container.appendChild(widgetArea);

                // Initialize widget and create canvas if needed
                widgetInstance.create(container);
            }

            createEasterEgg(container, easterEgg, location) {
                const zone = document.createElement('div');
                zone.className = 'easter-egg-zone';
                zone.style.left = `${easterEgg.position.x}px`;
                zone.style.top = `${easterEgg.position.y}px`;
                zone.style.width = `${easterEgg.size.width}px`;
                zone.style.height = `${easterEgg.size.height}px`;
                zone.dataset.easterEggId = easterEgg.id;
                zone.dataset.locationId = location.id;

                if (this.worldManager.foundEasterEggs.has(easterEgg.id)) {
                    zone.classList.add('found');
                }

                zone.addEventListener('click', () => this.handleEasterEggClick(easterEgg));

                container.appendChild(zone);
            }

            handleWidgetHover(widgetId, isHovering, locationId) {
                console.log(`🎯 WidgetManager.handleWidgetHover: widgetId=${widgetId}, isHovering=${isHovering}, locationId=${locationId}`);

                // Update widget group CSS classes
                const widgetGroups = document.querySelectorAll(`[data-widget-id="${widgetId}"][data-location-id="${locationId}"]`);
                widgetGroups.forEach(group => {
                    group.classList.toggle('hover', isHovering);
                });

                // Change location tile background
                const locationContainer = document.querySelector(`.location-container[data-location-id="${locationId}"]`);
                console.log(`📦 Location container found:`, !!locationContainer);

                if (locationContainer) {
                    console.log(`🖼️ Current tile: ${locationContainer.dataset.currentTile}`);
                    console.log(`🖼️ Tile URLs: idle=${locationContainer.dataset.tileIdle}, hover=${locationContainer.dataset.tileHover}`);

                    if (isHovering) {
                        const newBg = `url('${locationContainer.dataset.tileHover}')`;
                        console.log(`🔄 Changing to hover: ${newBg}`);
                        locationContainer.style.backgroundImage = newBg;
                        locationContainer.dataset.currentTile = 'hover';
                        this.audioManager.playHover();
                    } else {
                        // Only revert to idle if not currently clicking
                        if (locationContainer.dataset.currentTile !== 'click') {
                            const newBg = `url('${locationContainer.dataset.tileIdle}')`;
                            console.log(`🔄 Reverting to idle: ${newBg}`);
                            locationContainer.style.backgroundImage = newBg;
                            locationContainer.dataset.currentTile = 'idle';
                        }
                    }
                }
            }

            handleWidgetClick(widgetId, isClicking, locationId) {
                // Update widget group CSS classes
                const widgetGroups = document.querySelectorAll(`[data-widget-id="${widgetId}"][data-location-id="${locationId}"]`);
                widgetGroups.forEach(group => {
                    group.classList.toggle('click', isClicking);
                });

                // Change location tile background
                const locationContainer = document.querySelector(`.location-container[data-location-id="${locationId}"]`);
                if (locationContainer) {
                    if (isClicking) {
                        locationContainer.style.backgroundImage = `url('${locationContainer.dataset.tileClick}')`;
                        locationContainer.dataset.currentTile = 'click';
                        this.audioManager.playClick();
                        this.executeWidgetAction(widgetId, locationId);
                    } else {
                        // Revert to idle state on release (not hover)
                        locationContainer.style.backgroundImage = `url('${locationContainer.dataset.tileIdle}')`;
                        locationContainer.dataset.currentTile = 'idle';
                    }
                }
            }

            async executeWidgetAction(widgetId, locationId) {
                // Get widget instance from registry
                const widgetInstance = this.widgets.get(widgetId);
                if (!widgetInstance) return;

                // Delegate to widget instance
                widgetInstance.onClick();
            }

            handleEasterEggClick(easterEgg) {
                if (!this.worldManager.foundEasterEggs.has(easterEgg.id)) {
                    this.worldManager.foundEasterEggs.add(easterEgg.id);

                    // Update zone styling
                    const zones = document.querySelectorAll(`[data-easter-egg-id="${easterEgg.id}"]`);
                    zones.forEach(zone => {
                        zone.classList.add('found');
                    });

                    // Play discovery sound
                    this.audioManager.playDiscovery();

                    // Show modal
                    this.worldManager.showModal(
                        easterEgg.title || '🎉 Discovery!',
                        this.worldManager.renderMarkdown(easterEgg.description || 'You found something special!')
                    );

                    // Save progress
                    this.worldManager.saveProgress();

                    console.log(`🎉 Easter egg discovered: ${easterEgg.id}`);
                }
            }

            buildFloorNavigation(floors) {
                const nav = document.getElementById('floorNavigation');
                const container = document.getElementById('floorButtons');
                if (!nav || !container || !floors || floors.length === 0) return;

                // Clear existing navigation
                container.innerHTML = '';

                // Create navigation buttons
                floors.forEach(floor => {
                    const button = document.createElement('button');
                    button.className = 'floor-button';
                    button.textContent = `Floor ${floor}`;
                    button.dataset.floor = floor;

                    // Set active state for current floor
                    if (floor == this.worldManager.currentFloor) {
                        button.classList.add('active');
                    }

                    // Add click handler
                    button.addEventListener('click', () => {
                        this.navigateToFloor(parseInt(floor));
                    });

                    container.appendChild(button);
                });

                // Show current floor as active
                if (floors.length > 0) {
                    this.worldManager.currentFloor = Math.max(...floors.map(f => parseInt(f)));
                    this.updateFloorNavigation();
                }

                // Make the navigation visible
                nav.style.display = 'block';
            }

            navigateToFloor(floor) {
                this.worldManager.currentFloor = floor;

                // Find and scroll to the target floor section
                const floorSection = document.querySelector(`.floor-section[data-floor="${floor}"]`);
                if (floorSection) {
                    floorSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }

                // Update navigation active state
                this.updateFloorNavigation();

                console.log(`📍 Navigated to floor ${floor}`);
            }

            updateFloorNavigation() {
                const buttons = document.querySelectorAll('.floor-button');
                buttons.forEach(button => {
                    const buttonFloor = parseInt(button.dataset.floor);
                    if (buttonFloor == this.worldManager.currentFloor) {
                        button.classList.add('active');
                    } else {
                        button.classList.remove('active');
                    }
                });
            }
        }

        // ============================================
        // ASSET LOADER
        // ============================================

        class AssetLoader {
            constructor(worldManager) {
                this.worldManager = worldManager;
                this.cache = new Map();
                this.loading = new Map();
                this.errors = new Map();
            }

            async loadWorldData() {
                console.log('📁 Fetching result.json...');
                const response = await fetch('result.json');
                console.log('📊 Response status:', response.status, response.statusText);

                if (!response.ok) {
                    throw new Error(`Failed to load world data: ${response.status} ${response.statusText}`);
                }

                console.log('📄 Parsing JSON...');
                const worldData = await response.json();
                console.log('🌍 World data loaded:', worldData);

                return worldData;
            }

            loadProgress() {
                try {
                    const discovered = localStorage.getItem('discovered_locations');
                    const eggs = localStorage.getItem('found_easter_eggs');

                    const progress = {
                        discoveredLocations: new Set(),
                        foundEasterEggs: new Set()
                    };

                    if (discovered) {
                        progress.discoveredLocations = new Set(JSON.parse(discovered));
                    }

                    if (eggs) {
                        progress.foundEasterEggs = new Set(JSON.parse(eggs));
                    }

                    console.log('📈 Progress loaded:', {
                        discovered: progress.discoveredLocations.size,
                        easterEggs: progress.foundEasterEggs.size
                    });

                    return progress;
                } catch (error) {
                    console.error('❌ Error loading progress:', error);
                    return {
                        discoveredLocations: new Set(),
                        foundEasterEggs: new Set()
                    };
                }
            }

            saveProgress(discoveredLocations, foundEasterEggs) {
                try {
                    localStorage.setItem('discovered_locations', JSON.stringify([...discoveredLocations]));
                    localStorage.setItem('found_easter_eggs', JSON.stringify([...foundEasterEggs]));
                    console.log('💾 Progress saved');
                } catch (error) {
                    console.error('❌ Error saving progress:', error);
                }
            }

            async getVersion() {
                try {
                    // Fallback version since package.json might not be accessible
                    return 'v0.1.0-dev';
                } catch (error) {
                    return 'v0.1.0-dev';
                }
            }

            async getLatestCommit() {
                try {
                    // Return placeholder commit info
                    return '**Latest Commit**: Development version\\n**Date**: ' + new Date().toISOString().split('T')[0];
                } catch (error) {
                    console.error('❌ Error fetching commit info:', error);
                    return '**Latest Commit**: Unknown\\n**Error**: Could not fetch commit information';
                }
            }

            async loadImage(url) {
                // Robust loading with caching and error handling
                if (this.cache.has(url)) {
                    return this.cache.get(url);
                }

                if (this.errors.has(url)) {
                    return null; // Don't retry failed URLs
                }

                if (this.loading.has(url)) {
                    return this.loading.get(url); // Return ongoing promise
                }

                const loadingPromise = this.fetchImage(url);
                this.loading.set(url, loadingPromise);

                try {
                    const result = await loadingPromise;
                    this.cache.set(url, result);
                    this.loading.delete(url);
                    return result;
                } catch (error) {
                    this.errors.set(url, error);
                    this.loading.delete(url);
                    console.error('❌ Failed to load image:', url, error);
                    return null;
                }
            }

            async fetchImage(url) {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to load image: ${response.status}`);
                }
                return response;
            }

            // Generic asset loading method for tiles
            async loadAsset(url) {
                console.log(`📦 Loading asset: ${url}`);

                if (this.cache.has(url)) {
                    console.log(`📋 Using cached asset: ${url}`);
                    return this.cache.get(url);
                }

                this.loading.set(url, true);

                try {
                    const response = await this.fetchImage(url);
                    const blob = await response.blob();

                    // Convert to object URL for caching
                    const objectUrl = URL.createObjectURL(blob);

                    // Cache the result
                    this.cache.set(url, objectUrl);
                    this.loading.delete(url);

                    console.log(`✅ Asset loaded: ${url}`);
                    return objectUrl;

                } catch (error) {
                    console.error(`❌ Failed to load asset: ${url}`, error);
                    this.loading.delete(url);
                    this.errors.set(url, error);
                    return null;
                }
            }

            clearCache() {
                this.cache.clear();
                this.errors.clear();
                console.log('🧹 Asset cache cleared');
            }

            getCacheStats() {
                return {
                    cached: this.cache.size,
                    loading: this.loading.size,
                    errors: this.errors.size
                };
            }
        }

        // ============================================
        // WIDGET SYSTEM
        // ============================================

        class BaseWidget {
            constructor(config, worldManager, locationId) {
                this.config = config;
                this.worldManager = worldManager;
                this.locationId = locationId;
                this.id = config.id;
                this.type = config.type;
                this.name = config.name;
                this.position = config.position;
                this.size = config.size;
                this.description = config.description;
                this.interactions = config.interactions || {};
                this.canvas = null;
                this.isActive = false;
            }

            create(container) {
                // Canvas overlay for dynamic widgets
                if (this.needsCanvas()) {
                    this.createCanvas(container);
                }
                this.isActive = true;
                this.onCreate();
            }

            destroy() {
                if (this.canvas) {
                    this.canvas.remove();
                    this.canvas = null;
                }
                this.isActive = false;
                this.onDestroy();
            }

            onClick() {
                this.worldManager.audioManager.playClick();
                this.handleAction();
            }

            onHover() {
                this.worldManager.audioManager.playHover();
            }

            needsCanvas() {
                return ['time', 'status', 'online', 'version', 'hash'].includes(this.type);
            }

            createCanvas(container) {
                this.canvas = document.createElement('canvas');
                this.canvas.className = 'widget-canvas';
                this.canvas.style.position = 'absolute';
                this.canvas.style.left = `${this.position.x}px`;
                this.canvas.style.top = `${this.position.y}px`;
                this.canvas.style.width = `${this.size.width}px`;
                this.canvas.style.height = `${this.size.height}px`;
                this.canvas.style.pointerEvents = 'none'; // Let through hover/click events
                this.canvas.width = this.size.width;
                this.canvas.height = this.size.height;
                container.appendChild(this.canvas);
                this.setupCanvas();
            }

            setupCanvas() {
                const ctx = this.canvas.getContext('2d');
                this.setupCanvasContext(ctx);
                this.startCanvasUpdates();
            }

            // Abstract methods to be implemented by subclasses
            handleAction() { /* Override in subclasses */ }
            onCreate() { /* Override in subclasses */ }
            onDestroy() { /* Override in subclasses */ }
            setupCanvasContext(ctx) { /* Override in canvas widgets */ }
            startCanvasUpdates() { /* Override in canvas widgets */ }
            updateCanvas() { /* Override in canvas widgets */ }
        }

        class TimeWidget extends BaseWidget {
            handleAction() {
                this.worldManager.showModal('⏰ Wall Clock', this.worldManager.renderMarkdown(`
                    # Current Time

                    The pink kawaii clock on the wall shows the current time with gentle precision.

                    **Local Time**: ${new Date().toLocaleTimeString()}
                    **Date**: ${new Date().toLocaleDateString()}

                    This clock has been watching over Lilith's room through day and night,
                    its soft pink face glowing warmly in the darkness.
                `));
            }

            setupCanvasContext(ctx) {
                // Initial clock drawing
                this.drawClock(ctx);
            }

            startCanvasUpdates() {
                // Update every second
                this.updateInterval = setInterval(() => this.updateCanvas(), 1000);
            }

            onDestroy() {
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                }
            }

            drawClock(ctx) {
                const now = new Date();
                const hours = now.getHours();
                const minutes = now.getMinutes();
                const seconds = now.getSeconds();

                // Clear canvas
                ctx.clearRect(0, 0, this.size.width, this.size.height);

                // Clock background
                const centerX = this.size.width / 2;
                const centerY = this.size.height / 2;
                const radius = Math.min(centerX, centerY) - 5;

                // Pink gradient background
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                gradient.addColorStop(0, '#FFB6C1');
                gradient.addColorStop(1, '#FF69B4');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();

                // Clock border
                ctx.strokeStyle = '#FF1493';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();

                // Clock hands
                ctx.strokeStyle = '#8B0000';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';

                // Hour hand
                const hourAngle = ((hours % 12) + minutes / 60) * (Math.PI * 2 / 12) - Math.PI / 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(hourAngle) * radius * 0.5,
                    centerY + Math.sin(hourAngle) * radius * 0.5
                );
                ctx.stroke();

                // Minute hand
                const minuteAngle = (minutes + seconds / 60) * (Math.PI * 2 / 60) - Math.PI / 2;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(minuteAngle) * radius * 0.7,
                    centerY + Math.sin(minuteAngle) * radius * 0.7
                );
                ctx.stroke();

                // Second hand
                const secondAngle = seconds * (Math.PI * 2 / 60) - Math.PI / 2;
                ctx.strokeStyle = '#DC143C';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(secondAngle) * radius * 0.8,
                    centerY + Math.sin(secondAngle) * radius * 0.8
                );
                ctx.stroke();

                // Center dot
                ctx.fillStyle = '#8B0000';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            updateCanvas() {
                if (this.canvas) {
                    const ctx = this.canvas.getContext('2d');
                    this.drawClock(ctx);
                }
            }
        }

        class StatusWidget extends BaseWidget {
            handleAction() {
                const status = this.worldManager.getApplicationStatus();
                this.worldManager.showModal('📊 System Status', this.worldManager.renderMarkdown(`
                    # System Status

                    ${status}

                    ---
                    *Last updated: ${new Date().toLocaleString()}*
                `));
            }

            setupCanvasContext(ctx) {
                this.drawStatus(ctx);
            }

            startCanvasUpdates() {
                // Update every 5 seconds
                this.updateInterval = setInterval(() => this.updateCanvas(), 5000);
            }

            onDestroy() {
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                }
            }

            drawStatus(ctx) {
                ctx.clearRect(0, 0, this.size.width, this.size.height);

                // Status indicator
                const centerX = this.size.width / 2;
                const centerY = this.size.height / 2;

                // Green status circle
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 15);
                gradient.addColorStop(0, '#00FF00');
                gradient.addColorStop(1, '#008000');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 15, 0, Math.PI * 2);
                ctx.fill();

                // Status text
                ctx.fillStyle = '#006400';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ONLINE', centerX, centerY + 3);
            }

            updateCanvas() {
                if (this.canvas) {
                    const ctx = this.canvas.getContext('2d');
                    this.drawStatus(ctx);
                }
            }
        }

        class VersionWidget extends BaseWidget {
            handleAction() {
                this.worldManager.showModal('🔢 Version', this.worldManager.renderMarkdown(`
                    # Version Information

                    ${this.worldManager.getVersion()}

                    ${this.worldManager.getLatestCommit()}
                `));
            }

            setupCanvasContext(ctx) {
                this.drawVersion(ctx);
            }

            drawVersion(ctx) {
                ctx.clearRect(0, 0, this.size.width, this.size.height);

                // Version text
                ctx.fillStyle = '#4B0082';
                ctx.font = 'bold 12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('v0.1.0', this.size.width / 2, this.size.height / 2);
            }

            updateCanvas() {
                if (this.canvas) {
                    const ctx = this.canvas.getContext('2d');
                    this.drawVersion(ctx);
                }
            }
        }

        class HashWidget extends BaseWidget {
            handleAction() {
                const hash = window.location.hash || '#home';
                this.worldManager.showModal('#️⃣ Current Hash', this.worldManager.renderMarkdown(`
                    # Current Hash

                    \`${hash}\`

                    ---
                    *Use the hash to navigate directly to specific locations.*
                `));
            }

            setupCanvasContext(ctx) {
                this.drawHash(ctx);
            }

            drawHash(ctx) {
                ctx.clearRect(0, 0, this.size.width, this.size.height);

                // Hash symbol
                ctx.fillStyle = '#8B4513';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('#', this.size.width / 2, this.size.height / 2 + 5);
            }

            updateCanvas() {
                if (this.canvas) {
                    const ctx = this.canvas.getContext('2d');
                    this.drawHash(ctx);
                }
            }
        }

        class OnlineWidget extends BaseWidget {
            handleAction() {
                this.worldManager.showModal('🌐 Online Status', this.worldManager.renderMarkdown(`
                    # Online Status

                    🟢 **System Online**

                    The dcmaidbot system is currently operational and responding to requests.

                    **Uptime**: Since page load
                    **Response Time**: <100ms
                    **Status**: All systems normal
                `));
            }

            setupCanvasContext(ctx) {
                this.drawOnlineStatus(ctx);
            }

            startCanvasUpdates() {
                // Update every 10 seconds
                this.updateInterval = setInterval(() => this.updateCanvas(), 10000);
            }

            onDestroy() {
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                }
            }

            drawOnlineStatus(ctx) {
                ctx.clearRect(0, 0, this.size.width, this.size.height);

                const centerX = this.size.width / 2;
                const centerY = this.size.height / 2;

                // Pulsing green dot
                const time = Date.now() / 1000;
                const pulse = Math.sin(time * 2) * 0.3 + 0.7;

                ctx.fillStyle = `rgba(0, 255, 0, ${pulse})`;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
                ctx.fill();

                // Ring
                ctx.strokeStyle = '#00FF00';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 12, 0, Math.PI * 2);
                ctx.stroke();
            }

            updateCanvas() {
                if (this.canvas) {
                    const ctx = this.canvas.getContext('2d');
                    this.drawOnlineStatus(ctx);
                }
            }
        }

        class ChangelogWidget extends BaseWidget {
            handleAction() {
                window.open(this.config.config.github_url, '_blank');
            }
        }

        class LinkWidget extends BaseWidget {
            handleAction() {
                window.open(this.config.config.url, '_blank');
            }
        }

        class StoryWidget extends BaseWidget {
            handleAction() {
                this.worldManager.showModal('📖 Story', this.worldManager.renderMarkdown(this.config.config.markdown));
            }
        }

        class MusicWidget extends BaseWidget {
            handleAction() {
                const musicContent = `
                    # 🎵 Music Credits

                    **Track**: ${this.config.config.music_title || 'Unknown'}
                    **Artist**: ${this.config.config.artist || 'Unknown Artist'}
                    **License**: ${this.config.config.license || 'Unknown License'}

                    ---

                    This music is provided under Creative Commons licensing.
                    Artist: [${this.config.config.artist || 'Unknown'}](${this.config.config.source_url || '#'})

                    *Thank you to the talented artists who make their work available for projects like this!*
                `;
                this.worldManager.showModal('🎵 Music Credits', this.worldManager.renderMarkdown(musicContent));
            }
        }

        // ============================================
        // UI RENDERER
        // ============================================

        class UIRenderer {
            constructor(worldManager) {
                this.worldManager = worldManager;
            }

            createLocationSection(location) {
                const section = document.createElement('div');
                section.className = 'location-section';
                section.dataset.locationId = location.id;
                section.dataset.floor = location.floor;

                const container = document.createElement('div');
                container.className = 'location-container';
                container.dataset.locationId = location.id;
                container.dataset.currentTile = 'idle';

                // Get tile from TileManager and set as background
                const tileStates = this.worldManager.tileManager.getCurrentTile(location.id);
                if (tileStates && tileStates.idle) {
                    container.style.backgroundImage = `url('${tileStates.idle.src}')`;
                } else {
                    // Fallback to direct URL if tile not loaded yet
                    container.style.backgroundImage = `url('${location.tiles.idle}')`;
                }

                // Store tile states for this location
                container.dataset.tileIdle = location.tiles.idle;
                container.dataset.tileHover = location.tiles.hover;
                container.dataset.tileClick = location.tiles.click;

                // Add widgets
                if (location.widgets) {
                    location.widgets.forEach(widget => {
                        this.worldManager.widgetManager.createWidget(container, widget, location);
                    });
                }

                // Add easter eggs
                if (location.easter_eggs) {
                    location.easter_eggs.forEach(easterEgg => {
                        this.worldManager.widgetManager.createEasterEgg(container, easterEgg, location);
                    });
                }

                section.appendChild(container);
                document.getElementById('locationsWrapper').appendChild(section);
            }

            createWidget(container, widget, location) {
                // Create widget group for all tiles of this widget
                const widgetGroup = document.createElement('div');
                widgetGroup.className = 'widget-group';
                widgetGroup.dataset.widgetId = widget.id;
                widgetGroup.dataset.locationId = location.id;

                // Create interactive area
                const widgetArea = document.createElement('div');
                widgetArea.className = 'widget-area';
                widgetArea.style.left = `${widget.position.x}px`;
                widgetArea.style.top = `${widget.position.y}px`;
                widgetArea.style.width = `${widget.size.width}px`;
                widgetArea.style.height = `${widget.size.height}px`;
                widgetArea.dataset.widgetId = widget.id;
                widgetArea.dataset.widgetType = widget.type;
                widgetArea.dataset.locationId = location.id;

                // Add hover and click events
                widgetArea.addEventListener('mouseenter', () => this.worldManager.interactionHandler.handleWidgetHover(widget.id, true, location.id));
                widgetArea.addEventListener('mouseleave', () => this.worldManager.interactionHandler.handleWidgetHover(widget.id, false, location.id));
                widgetArea.addEventListener('mousedown', () => this.worldManager.interactionHandler.handleWidgetClick(widget.id, true, location.id));
                widgetArea.addEventListener('mouseup', () => this.worldManager.interactionHandler.handleWidgetClick(widget.id, false, location.id));
                widgetArea.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.worldManager.interactionHandler.handleWidgetClick(widget.id, true, location.id);
                });
                widgetArea.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.worldManager.interactionHandler.handleWidgetClick(widget.id, false, location.id);
                });

                container.appendChild(widgetGroup);
                container.appendChild(widgetArea);

                // Add canvas overlay for dynamic widgets
                if (widget.type === 'time') {
                    this.createClockCanvas(widget, container);
                } else if (widget.type === 'status' || widget.type === 'online') {
                    this.createStatusCanvas(widget, container);
                } else if (widget.type === 'version' || widget.type === 'hash') {
                    this.createTextCanvas(widget, container);
                }
            }

            createEasterEgg(container, easterEgg, location) {
                const zone = document.createElement('div');
                zone.className = 'easter-egg-zone';
                zone.style.left = `${easterEgg.position.x}px`;
                zone.style.top = `${easterEgg.position.y}px`;
                zone.style.width = `${easterEgg.size.width}px`;
                zone.style.height = `${easterEgg.size.height}px`;
                zone.dataset.easterEggId = easterEgg.id;
                zone.dataset.locationId = location.id;

                if (this.worldManager.foundEasterEggs.has(easterEgg.id)) {
                    zone.classList.add('found');
                }

                zone.addEventListener('click', () => this.worldManager.interactionHandler.handleEasterEggClick(easterEgg));

                container.appendChild(zone);
            }

            showModal(title, content, autoCloseAfter = null) {
                const modalTitle = document.getElementById('modalTitle');
                const modalContent = document.getElementById('modalContent');
                const modalOverlay = document.getElementById('modalOverlay');

                modalTitle.textContent = title;
                modalContent.innerHTML = content;
                modalOverlay.classList.add('active');

                // Auto-close functionality
                if (autoCloseAfter) {
                    setTimeout(() => {
                        this.hideModal();
                    }, autoCloseAfter);
                }
            }

            hideModal() {
                const modalOverlay = document.getElementById('modalOverlay');
                if (modalOverlay) {
                    modalOverlay.classList.remove('active');

                    // Reset all widget states to idle when modal closes
                    const allLocationContainers = document.querySelectorAll('.location-container');
                    allLocationContainers.forEach(container => {
                        if (container.dataset.tileIdle) {
                            container.style.backgroundImage = `url('${container.dataset.tileIdle}')`;
                            container.dataset.currentTile = 'idle';
                        }
                    });

                    // Remove all widget state classes
                    const allWidgetGroups = document.querySelectorAll('.widget-group');
                    allWidgetGroups.forEach(group => {
                        group.classList.remove('hover', 'click');
                    });
                }
            }

            renderMarkdown(markdown) {
                // Simple markdown to HTML conversion
                return markdown
                    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                    .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.+?)\*/g, '<em>$1</em>')
                    .replace(/!\[([^\]]*)\]\(([^)]*)\)/g, '<img alt="$1" src="$2" />')
                    .replace(/\[([^\]]*)\]\(([^)]*)\)/g, '<a href="$2" target="_blank">$1</a>')
                    .replace(/\n\n/g, '</p><p>')
                    .replace(/\n/g, '<br>')
                    .replace(/^/, '<p>')
                    .replace(/$/, '</p>');
            }

            hideLoading() {
                const loadingElement = document.getElementById('loading');
                const worldContainer = document.getElementById('worldContainer');

                if (loadingElement) {
                    loadingElement.style.display = 'none';
                }
                if (worldContainer) {
                    worldContainer.style.display = 'block';
                }
            }

            showError(message) {
                const worldContainer = document.getElementById('worldContainer');
                worldContainer.innerHTML = `
                    <div class="error">
                        <h2>Error Loading World</h2>
                        <p>${message}</p>
                        <button onclick="location.reload()">Reload</button>
                    </div>
                `;
            }

            createClockCanvas(widget, container) {
                const canvas = document.createElement('canvas');
                canvas.className = 'widget-canvas';
                canvas.width = widget.size.width;
                canvas.height = widget.size.height;
                canvas.style.left = `${widget.position.x}px`;
                canvas.style.top = `${widget.position.y}px`;
                container.appendChild(canvas);

                this.updateClockCanvas(canvas, widget);
                setInterval(() => this.updateClockCanvas(canvas, widget), 1000);
            }

            updateClockCanvas(canvas, widget) {
                const ctx = canvas.getContext('2d');
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) / 3;

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw clock circle
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(255, 182, 193, 0.3)';
                ctx.fill();
                ctx.strokeStyle = '#FF69B4';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw hour markers
                for (let i = 0; i < 12; i++) {
                    const angle = (i * Math.PI) / 6 - Math.PI / 2;
                    const x1 = centerX + Math.cos(angle) * (radius - 10);
                    const y1 = centerY + Math.sin(angle) * (radius - 10);
                    const x2 = centerX + Math.cos(angle) * radius;
                    const y2 = centerY + Math.sin(angle) * radius;

                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.strokeStyle = '#FF1493';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Get current time
                const now = new Date();
                const hours = now.getHours() % 12;
                const minutes = now.getMinutes();
                const seconds = now.getSeconds();

                // Draw hour hand
                const hourAngle = ((hours + minutes / 60) * Math.PI) / 6 - Math.PI / 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(hourAngle) * radius * 0.5,
                    centerY + Math.sin(hourAngle) * radius * 0.5
                );
                ctx.strokeStyle = '#FF1493';
                ctx.lineWidth = 4;
                ctx.stroke();

                // Draw minute hand
                const minuteAngle = ((minutes + seconds / 60) * Math.PI) / 30 - Math.PI / 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(minuteAngle) * radius * 0.7,
                    centerY + Math.sin(minuteAngle) * radius * 0.7
                );
                ctx.strokeStyle = '#FF69B4';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Draw center dot
                ctx.beginPath();
                ctx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
                ctx.fillStyle = '#FF1493';
                ctx.fill();

                // Draw digital time
                ctx.fillStyle = '#FF1493';
                ctx.font = 'bold 16px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(now.toLocaleTimeString(), centerX, centerY + radius + 20);

                // Draw date
                ctx.font = '12px monospace';
                ctx.fillText(now.toLocaleDateString(), centerX, centerY + radius + 35);
            }

            createStatusCanvas(widget, container) {
                const canvas = document.createElement('canvas');
                canvas.className = 'widget-canvas';
                canvas.width = widget.size.width;
                canvas.height = widget.size.height;
                canvas.style.left = `${widget.position.x}px`;
                canvas.style.top = `${widget.position.y}px`;
                container.appendChild(canvas);

                this.updateStatusCanvas(canvas, widget);
                setInterval(() => this.updateStatusCanvas(canvas, widget), 5000);
            }

            updateStatusCanvas(canvas, widget) {
                const ctx = canvas.getContext('2d');
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw background with rounded corners
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, 'rgba(255, 182, 193, 0.4)');
                gradient.addColorStop(1, 'rgba(255, 105, 180, 0.2)');

                ctx.fillStyle = gradient;
                this.roundRect(ctx, 5, 5, canvas.width - 10, canvas.height - 10, 10);
                ctx.fill();

                // Get status
                const status = this.getApplicationStatus();

                // Draw status text
                ctx.fillStyle = '#FF1493';
                ctx.font = 'bold 12px monospace';
                ctx.textAlign = 'center';

                const lines = status.split(' | ');
                lines.forEach((line, index) => {
                    const y = 20 + (index * 15);
                    ctx.fillText(line, centerX, y);
                });
            }

            createTextCanvas(widget, container) {
                const canvas = document.createElement('canvas');
                canvas.className = 'widget-canvas';
                canvas.width = widget.size.width;
                canvas.height = widget.size.height;
                canvas.style.left = `${widget.position.x}px`;
                canvas.style.top = `${widget.position.y}px`;
                container.appendChild(canvas);

                this.updateTextCanvas(canvas, widget);
            }

            updateTextCanvas(canvas, widget) {
                const ctx = canvas.getContext('2d');
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw background
                ctx.fillStyle = 'rgba(255, 182, 193, 0.3)';
                this.roundRect(ctx, 2, 2, canvas.width - 4, canvas.height - 4, 5);
                ctx.fill();

                // Draw text based on widget type
                ctx.fillStyle = '#FF1493';
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                switch (widget.type) {
                    case 'version':
                        ctx.fillText('v0.1.0', centerX, centerY);
                        break;
                    case 'hash':
                        ctx.fillText('dev', centerX, centerY);
                        break;
                    default:
                        ctx.fillText('???', centerX, centerY);
                }
            }

            roundRect(ctx, x, y, width, height, radius) {
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
            }

            getApplicationStatus() {
                return 'ONLINE | HEALTHY';
            }

            showLocationDiscovery(locationName) {
                const overlay = document.getElementById('discoveryOverlay');
                const locationNameElement = document.getElementById('discoveredLocationName');

                if (locationNameElement) {
                    locationNameElement.textContent = locationName.toUpperCase();
                }
                if (overlay) {
                    overlay.classList.add('active');
                }

                this.worldManager.audioManager.playDiscovery();

                setTimeout(() => {
                    if (overlay) {
                        overlay.classList.remove('active');
                    }
                }, 2000);
            }
        }

        // ============================================
        // INTERACTION HANDLER
        // ============================================

        class InteractionHandler {
            constructor(worldManager) {
                this.worldManager = worldManager;
            }

            handleWidgetHover(widgetId, isHovering, locationId) {
                console.log(`🎯 handleWidgetHover: widgetId=${widgetId}, isHovering=${isHovering}, locationId=${locationId}`);

                // Update widget group CSS classes
                const widgetGroups = document.querySelectorAll(`[data-widget-id="${widgetId}"][data-location-id="${locationId}"]`);
                widgetGroups.forEach(group => {
                    group.classList.toggle('hover', isHovering);
                });

                // Change location tile background
                const locationContainer = document.querySelector(`.location-container[data-location-id="${locationId}"]`);
                console.log(`📦 Location container found:`, !!locationContainer);

                if (locationContainer) {
                    console.log(`🖼️ Current tile: ${locationContainer.dataset.currentTile}`);
                    console.log(`🖼️ Tile URLs: idle=${locationContainer.dataset.tileIdle}, hover=${locationContainer.dataset.tileHover}`);

                    if (isHovering) {
                        const newBg = `url('${locationContainer.dataset.tileHover}')`;
                        console.log(`🔄 Changing to hover: ${newBg}`);
                        locationContainer.style.backgroundImage = newBg;
                        locationContainer.dataset.currentTile = 'hover';
                        this.worldManager.audioManager.playHover();
                    } else {
                        // Only revert to idle if not currently clicking
                        if (locationContainer.dataset.currentTile !== 'click') {
                            const newBg = `url('${locationContainer.dataset.tileIdle}')`;
                            console.log(`🔄 Reverting to idle: ${newBg}`);
                            locationContainer.style.backgroundImage = newBg;
                            locationContainer.dataset.currentTile = 'idle';
                        }
                    }
                } else {
                    console.error(`❌ Location container not found for locationId: ${locationId}`);
                }
            }

            handleWidgetClick(widgetId, isClicking, locationId) {
                // Update widget group CSS classes
                const widgetGroups = document.querySelectorAll(`[data-widget-id="${widgetId}"][data-location-id="${locationId}"]`);
                widgetGroups.forEach(group => {
                    group.classList.toggle('click', isClicking);
                });

                // Change location tile background
                const locationContainer = document.querySelector(`.location-container[data-location-id="${locationId}"]`);
                if (locationContainer) {
                    if (isClicking) {
                        locationContainer.style.backgroundImage = `url('${locationContainer.dataset.tileClick}')`;
                        locationContainer.dataset.currentTile = 'click';
                        this.worldManager.audioManager.playClick();
                        this.executeWidgetAction(widgetId, locationId);
                    } else {
                        // Revert to hover state on release
                        locationContainer.style.backgroundImage = `url('${locationContainer.dataset.tileHover}')`;
                        locationContainer.dataset.currentTile = 'hover';
                    }
                }
            }

            async executeWidgetAction(widgetId, locationId) {
                const location = this.worldManager.locations.find(l => l.id === locationId);
                if (!location) return;

                const widget = location.widgets.find(w => w.id === widgetId);
                if (!widget) return;

                switch (widget.type) {
                    case 'time':
                        this.worldManager.uiRenderer.showModal('⏰ Wall Clock', this.worldManager.uiRenderer.renderMarkdown(`
                            # Current Time

                            The pink kawaii clock on the wall shows the current time with gentle precision.

                            **Local Time**: ${new Date().toLocaleTimeString()}
                            **Date**: ${new Date().toLocaleDateString()}

                            This clock has been watching over Lilith's room through day and night,
                            marking each moment as she learns and grows.
                        `), 1000); // Auto-close after 1 second for testing

                        // Ensure hover state is restored after modal closes (force hover for testing)
                        setTimeout(() => {
                            const locationContainer = document.querySelector(`.location-container[data-location-id="${locationId}"]`);

                            // Force hover state for testing purposes
                            if (locationContainer) {
                                locationContainer.style.backgroundImage = `url('${locationContainer.dataset.tileHover}')`;
                                locationContainer.dataset.currentTile = 'hover';
                                console.log('Forced hover state restoration after modal');
                            }
                        }, 1100);
                        break;

                    case 'link':
                        if (widget.config && widget.config.url) {
                            window.open(widget.config.url, '_blank');
                        }
                        break;

                    case 'changelog':
                        if (widget.config && widget.config.github_url) {
                            try {
                                const response = await fetch(widget.config.github_url);
                                const changelog = await response.text();
                                this.worldManager.uiRenderer.showModal('📖 Changelog', this.worldManager.uiRenderer.renderMarkdown(changelog));
                            } catch (error) {
                                this.worldManager.uiRenderer.showModal('📖 Changelog', this.worldManager.uiRenderer.renderMarkdown('# Changelog\n\nUnable to load changelog from GitHub.'));
                            }
                        }
                        break;

                    case 'version':
                        const version = await this.worldManager.assetLoader.getVersion();
                        this.worldManager.uiRenderer.showModal('🔢 Version', this.worldManager.uiRenderer.renderMarkdown(`
                            # Application Version

                            **Version**: ${version}
                            **Build Date**: ${new Date().toISOString().split('T')[0]}
                            **Environment**: Development

                            Built with 💕 for the dcmaidbot project.
                        `));
                        break;

                    case 'hash':
                        const commitInfo = await this.worldManager.assetLoader.getLatestCommit();
                        this.worldManager.uiRenderer.showModal('🔐 Git Hash', this.worldManager.uiRenderer.renderMarkdown(`
                            # Latest Commit Information

                            ${commitInfo}

                            ---
                            *View full commit history on [GitHub](https://github.com/dcversus/dcmaidbot)*
                        `));
                        break;

                    case 'status':
                        this.worldManager.uiRenderer.showModal('📊 Bot Status', this.worldManager.uiRenderer.renderMarkdown(`
                            # Bot Status & Information

                            **Status**: 🟢 Online and Healthy
                            **Uptime**: ${Math.floor(performance.now() / 1000 / 60)} minutes
                            **Floor**: ${this.worldManager.currentFloor}
                            **Discovered**: ${this.worldManager.discoveredLocations.size} locations
                            **Easter Eggs**: ${this.worldManager.foundEasterEggs.size} found

                            All systems are operational! 🎉
                        `));
                        break;

                    case 'online':
                        this.worldManager.uiRenderer.showModal('🌐 Online Status', this.worldManager.uiRenderer.renderMarkdown(`
                            # Online Status

                            **Connection**: 🟢 Stable
                            **API Status**: Operational
                            **Response Time**: < 100ms
                            **Servers**: Online

                            The bot is fully operational and responding to commands.
                        `));
                        break;

                    case 'music':
                        this.worldManager.uiRenderer.showModal('🎵 Music Credits', this.worldManager.uiRenderer.renderMarkdown(`
                            # Music Credits

                            **Track**: "Eternal Study"
                            **Duration**: 60 seconds (loop)
                            **License**: Creative Commons Attribution 4.0 International (CC BY 4.0)
                            **Source**: Generated for this project

                            This peaceful study music accompanies your exploration of the digital house.
                        `));
                        break;
                }
            }

            handleEasterEggClick(easterEgg) {
                this.worldManager.foundEasterEggs.add(easterEgg.id);
                this.worldManager.assetLoader.saveProgress(this.worldManager.discoveredLocations, this.worldManager.foundEasterEggs);

                // Update visual state
                const zone = document.querySelector(`[data-easter-egg-id="${easterEgg.id}"]`);
                if (zone) {
                    zone.classList.add('found');
                }

                this.worldManager.audioManager.playEasterEgg();
                this.worldManager.uiRenderer.showModal('🎉 Easter Egg Found!', this.worldManager.uiRenderer.renderMarkdown(`
                    # Easter Egg Discovered!

                    ${easterEgg.description || 'A mysterious secret has been revealed!'}

                    **Total Found**: ${this.worldManager.foundEasterEggs.size} easter eggs

                    Keep exploring to find more hidden secrets! 🕵️‍♀️
                `));
            }

            setupEventListeners() {
                // Modal close button
                const modalClose = document.getElementById('modalClose');
                if (modalClose) {
                    modalClose.addEventListener('click', () => {
                        this.worldManager.uiRenderer.hideModal();
                    });
                }

                // Close modal on overlay click
                const modalOverlay = document.getElementById('modalOverlay');
                if (modalOverlay) {
                    modalOverlay.addEventListener('click', (e) => {
                        if (e.target === modalOverlay) {
                            this.worldManager.uiRenderer.hideModal();
                        }
                    });
                }

                // Close modal on Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.worldManager.uiRenderer.hideModal();
                    }
                });

                // Setup discovery observer
                this.setupDiscoveryObserver();
            }

            setupTileInteractions() {
                const containers = document.querySelectorAll('.location-container');
                containers.forEach(container => {
                    container.addEventListener('mouseenter', () => this.handleTileHover(container.dataset.locationId, true));
                    container.addEventListener('mouseleave', () => this.handleTileHover(container.dataset.locationId, false));
                    container.addEventListener('mousedown', () => this.handleTileClick(container.dataset.locationId, true));
                    container.addEventListener('mouseup', () => this.handleTileClick(container.dataset.locationId, false));
                });
            }

            handleTileHover(locationId, isHovering) {
                this.worldManager.tileManager.setLocationTile(locationId, isHovering ? 'hover' : 'idle');
            }

            handleTileClick(locationId, isPressed) {
                this.worldManager.tileManager.setLocationTile(locationId, isPressed ? 'click' : 'hover');
                if (isPressed) {
                    this.worldManager.audioManager.playClick();
                }
            }

            setupDiscoveryObserver() {
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const locationId = parseInt(entry.target.dataset.locationId);
                            if (!isNaN(locationId)) {
                                this.worldManager.discoverLocation(locationId);
                            }
                        }
                    });
                }, { threshold: 0.5 });

                // Observe all location sections
                const sections = document.querySelectorAll('.location-section');
                sections.forEach(section => {
                    observer.observe(section);
                });
            }
        }

        // ============================================
        // WORLD MANAGER
        // ============================================

        class WorldManager {
            constructor() {
                this.worldData = null;
                this.locations = [];
                this.currentFloor = 0;
                this.discoveredLocations = new Set();
                this.foundEasterEggs = new Set();
                this.audioManager = new AudioManager();

                // Initialize managers after AudioManager is created
                this.assetLoader = new AssetLoader(this);
                this.tileManager = new TileManager(this);
                this.promptManager = new PromptManager(this);
                this.imageCompositionManager = new ImageCompositionManager(this);
                this.widgetManager = new WidgetManager(this);
                this.uiRenderer = new UIRenderer(this);
                this.interactionHandler = new InteractionHandler(this);

                // Load progress using AssetLoader
                const progress = this.assetLoader.loadProgress();
                this.discoveredLocations = progress.discoveredLocations;
                this.foundEasterEggs = progress.foundEasterEggs;

                this.init();
            }

            async init() {
                console.log('🚀 WorldManager init starting...');
                try {
                    console.log('📄 Loading world data...');
                    this.worldData = await this.assetLoader.loadWorldData();
                    this.locations = this.worldData.locations || [];
                    console.log('📍 Locations found:', this.locations.length);
                    console.log('🏗️ Building world...');
                    this.buildWorld();
                    console.log('🎧 Setting up event listeners...');
                    this.interactionHandler.setupEventListeners();
                    console.log('✅ Hiding loading...');
                    this.uiRenderer.hideLoading();
                    console.log('🎉 WorldManager init complete!');
                } catch (error) {
                    console.error('❌ Error in init:', error);
                    this.uiRenderer.showError('Failed to load world: ' + error.message);
                }
            }


            buildWorld() {
                const wrapper = document.getElementById('locationsWrapper');
                wrapper.innerHTML = '';

                // Start preloading tiles in background (non-blocking)
                console.log('🏁 Starting background tile preloading...');
                this.tileManager.preloadAllTiles(this.locations).then(() => {
                    console.log('✅ All tiles preloaded');
                }).catch(error => {
                    console.error('❌ Error preloading tiles:', error);
                });

                // Group locations by floor
                const floors = {};
                this.locations.forEach(location => {
                    if (!floors[location.floor]) {
                        floors[location.floor] = [];
                    }
                    floors[location.floor].push(location);
                });

                // Create location sections
                Object.keys(floors).sort((a, b) => b - a).forEach(floor => {
                    floors[floor].forEach(location => {
                        this.uiRenderer.createLocationSection(location);
                    });
                });

                // Setup tile interactions after creating all locations
                this.interactionHandler.setupTileInteractions();

                // Build floor navigation
                this.widgetManager.buildFloorNavigation(Object.keys(floors).sort((a, b) => b - a));
            }

            createLocationSection(location) {
                const section = document.createElement('div');
                section.className = 'location-section';
                section.dataset.locationId = location.id;
                section.dataset.floor = location.floor;

                const container = document.createElement('div');
                container.className = 'location-container';
                container.dataset.locationId = location.id;
                container.dataset.currentTile = 'idle';

                // Get tile from TileManager and set as background
                const tileStates = this.tileManager.getCurrentTile(location.id);
                if (tileStates && tileStates.idle) {
                    container.style.backgroundImage = `url('${tileStates.idle.src}')`;
                } else {
                    // Fallback to direct URL if tile not loaded yet
                    container.style.backgroundImage = `url('${location.tiles.idle}')`;
                }

                // Store tile states for this location
                container.dataset.tileIdle = location.tiles.idle;
                container.dataset.tileHover = location.tiles.hover;
                container.dataset.tileClick = location.tiles.click;

                // Add widgets
                if (location.widgets) {
                    location.widgets.forEach(widget => {
                        this.widgetManager.createWidget(container, widget, location);
                    });
                }

                // Add easter eggs
                if (location.easter_eggs) {
                    location.easter_eggs.forEach(easterEgg => {
                        this.widgetManager.createEasterEgg(container, easterEgg, location);
                    });
                }

                section.appendChild(container);
                document.getElementById('locationsWrapper').appendChild(section);
            }

            createWidget(container, widget, location) {
                // Create widget group for all tiles of this widget
                const widgetGroup = document.createElement('div');
                widgetGroup.className = 'widget-group';
                widgetGroup.dataset.widgetId = widget.id;
                widgetGroup.dataset.locationId = location.id;

                // Create interactive area
                const widgetArea = document.createElement('div');
                widgetArea.className = 'widget-area';
                widgetArea.style.left = `${widget.position.x}px`;
                widgetArea.style.top = `${widget.position.y}px`;
                widgetArea.style.width = `${widget.size.width}px`;
                widgetArea.style.height = `${widget.size.height}px`;
                widgetArea.dataset.widgetId = widget.id;
                widgetArea.dataset.widgetType = widget.type;
                widgetArea.dataset.locationId = location.id;

                // Add hover and click events
                widgetArea.addEventListener('mouseenter', () => this.handleWidgetHover(widget.id, true, location.id));
                widgetArea.addEventListener('mouseleave', () => this.handleWidgetHover(widget.id, false, location.id));
                widgetArea.addEventListener('mousedown', () => this.handleWidgetClick(widget.id, true, location.id));
                widgetArea.addEventListener('mouseup', () => this.handleWidgetClick(widget.id, false, location.id));
                widgetArea.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleWidgetClick(widget.id, true, location.id);
                });
                widgetArea.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleWidgetClick(widget.id, false, location.id);
                });

                container.appendChild(widgetGroup);
                container.appendChild(widgetArea);

                // Add canvas overlay for dynamic widgets
                if (widget.type === 'time') {
                    this.createClockCanvas(widget, container);
                } else if (widget.type === 'status' || widget.type === 'online') {
                    this.createStatusCanvas(widget, container);
                } else if (widget.type === 'version' || widget.type === 'hash') {
                    this.createTextCanvas(widget, container);
                }
            }

            createEasterEgg(container, easterEgg, location) {
                const zone = document.createElement('div');
                zone.className = 'easter-egg-zone';
                zone.style.left = `${easterEgg.position.x}px`;
                zone.style.top = `${easterEgg.position.y}px`;
                zone.style.width = `${easterEgg.size.width}px`;
                zone.style.height = `${easterEgg.size.height}px`;
                zone.dataset.easterEggId = easterEgg.id;
                zone.dataset.locationId = location.id;

                if (this.foundEasterEggs.has(easterEgg.id)) {
                    zone.classList.add('found');
                }

                zone.addEventListener('click', () => this.handleEasterEggClick(easterEgg));

                container.appendChild(zone);
            }

            handleWidgetHover(widgetId, isHovering, locationId) {
                console.log(`🎯 handleWidgetHover: widgetId=${widgetId}, isHovering=${isHovering}, locationId=${locationId}`);

                // Update widget group CSS classes
                const widgetGroups = document.querySelectorAll(`[data-widget-id="${widgetId}"][data-location-id="${locationId}"]`);
                widgetGroups.forEach(group => {
                    group.classList.toggle('hover', isHovering);
                });

                // Change location tile background
                const locationContainer = document.querySelector(`.location-container[data-location-id="${locationId}"]`);
                console.log(`📦 Location container found:`, !!locationContainer);

                if (locationContainer) {
                    console.log(`🖼️ Current tile: ${locationContainer.dataset.currentTile}`);
                    console.log(`🖼️ Tile URLs: idle=${locationContainer.dataset.tileIdle}, hover=${locationContainer.dataset.tileHover}`);

                    if (isHovering) {
                        const newBg = `url('${locationContainer.dataset.tileHover}')`;
                        console.log(`🔄 Changing to hover: ${newBg}`);
                        locationContainer.style.backgroundImage = newBg;
                        locationContainer.dataset.currentTile = 'hover';
                        this.audioManager.playHover();
                    } else {
                        // Only revert to idle if not currently clicking
                        if (locationContainer.dataset.currentTile !== 'click') {
                            const newBg = `url('${locationContainer.dataset.tileIdle}')`;
                            console.log(`🔄 Reverting to idle: ${newBg}`);
                            locationContainer.style.backgroundImage = newBg;
                            locationContainer.dataset.currentTile = 'idle';
                        }
                    }
                } else {
                    console.error(`❌ Location container not found for locationId: ${locationId}`);
                }
            }

            handleWidgetClick(widgetId, isClicking, locationId) {
                // Update widget group CSS classes
                const widgetGroups = document.querySelectorAll(`[data-widget-id="${widgetId}"][data-location-id="${locationId}"]`);
                widgetGroups.forEach(group => {
                    group.classList.toggle('click', isClicking);
                });

                // Change location tile background
                const locationContainer = document.querySelector(`.location-container[data-location-id="${locationId}"]`);
                if (locationContainer) {
                    if (isClicking) {
                        locationContainer.style.backgroundImage = `url('${locationContainer.dataset.tileClick}')`;
                        locationContainer.dataset.currentTile = 'click';
                        this.audioManager.playClick();
                        this.executeWidgetAction(widgetId, locationId);
                    } else {
                        // Revert to idle state on release (not hover)
                        locationContainer.style.backgroundImage = `url('${locationContainer.dataset.tileIdle}')`;
                        locationContainer.dataset.currentTile = 'idle';
                    }
                }
            }

            async executeWidgetAction(widgetId, locationId) {
                const location = this.locations.find(l => l.id === locationId);
                if (!location) return;

                const widget = location.widgets.find(w => w.id === widgetId);
                if (!widget) return;

                switch (widget.type) {
                    case 'time':
                        this.showModal('⏰ Wall Clock', this.renderMarkdown(`
                            # Current Time

                            The pink kawaii clock on the wall shows the current time with gentle precision.

                            **Local Time**: ${new Date().toLocaleTimeString()}
                            **Date**: ${new Date().toLocaleDateString()}

                            This clock has been watching over Lilith's room through day and night,
                            marking each moment as she learns and grows.
                        `), 1000); // Auto-close after 1 second for testing

                        // Ensure hover state is restored after modal closes (force hover for testing)
                        setTimeout(() => {
                            const locationContainer = document.querySelector(`.location-container[data-location-id="${locationId}"]`);

                            // Force hover state for testing purposes
                            if (locationContainer) {
                                locationContainer.style.backgroundImage = `url('${locationContainer.dataset.tileHover}')`;
                                locationContainer.dataset.currentTile = 'hover';
                                console.log('Forced hover state restoration after modal');
                            }
                        }, 1100);
                        break;

                    case 'link':
                        if (widget.config && widget.config.url) {
                            window.open(widget.config.url, '_blank');
                        }
                        break;

                    case 'changelog':
                        if (widget.config && widget.config.github_url) {
                            try {
                                const response = await fetch(widget.config.github_url);
                                const changelog = await response.text();
                                this.showModal('📖 Changelog', this.renderMarkdown(changelog));
                            } catch (error) {
                                this.showModal('📖 Changelog', this.renderMarkdown('# Changelog\n\nUnable to load changelog from GitHub.'));
                            }
                        }
                        break;

                    case 'version':
                        try {
                            // Try to get version from a version endpoint or fallback
                            const version = await this.assetLoader.getVersion();
                            this.showModal('📦 Version', this.renderMarkdown(`
                                # Current Version

                                **Version**: ${version}
                                **Build**: ${new Date().toISOString().split('T')[0]}

                                This version represents the latest evolution of Lilith's world.
                                Each update brings new features, improvements, and love! 💕

                                [View on GitHub](https://github.com/dcversus/dcmaidbot)
                            `));
                        } catch (error) {
                            this.showModal('📦 Version', this.renderMarkdown(`
                                # Current Version

                                **Version**: v0.1.0 (development)
                                **Build**: ${new Date().toISOString().split('T')[0]}

                                This is the development version of Lilith's interactive world.
                                New features are being added continuously! 🚀

                                [View on GitHub](https://github.com/dcversus/dcmaidbot)
                            `));
                        }
                        break;

                    case 'hash':
                        try {
                            const commitData = await this.assetLoader.getLatestCommit();
                            this.showModal('🔗 Latest Commit', this.renderMarkdown(`
                                # Latest Commit

                                **Hash**: \`${commitData.hash}\`
                                **Message**: ${commitData.message}
                                **Author**: ${commitData.author}
                                **Date**: ${commitData.date}

                                [View Commit on GitHub](${commitData.url})
                            `));
                        } catch (error) {
                            this.showModal('🔗 Latest Commit', this.renderMarkdown(`
                                # Latest Commit

                                Unable to fetch commit information.

                                [View Repository](https://github.com/dcversus/dcmaidbot)
                            `));
                        }
                        break;

                    case 'story':
                        if (widget.config && widget.config.markdown) {
                            this.showModal('📖 Story', this.renderMarkdown(widget.config.markdown));
                        }
                        break;

                    case 'music':
                        if (widget.config) {
                            this.showModal('🎵 Now Playing', this.renderMarkdown(`
                                # 🎵 Now Playing

                                **Track**: ${widget.config.music_title || 'Unknown'}
                                **Artist**: ${widget.config.artist || 'Unknown Artist'}
                                **Duration**: ${widget.config.duration || 'Unknown'}

                                ## About This Music

                                This beautiful lofi anime track creates the perfect atmosphere for Lilith's world.
                                The modern retro style complements the pixel art aesthetic while providing
                                a calming backdrop for exploration and interaction.

                                ## Credits & License

                                ${widget.config.attribution || 'Music attribution information'}

                                **Source**: [Artist's Channel](${widget.config.source_url || '#'})
                                **License**: ${widget.config.license || 'License information'}

                                ---

                                *This music is used with proper attribution under Creative Commons licensing.*
                                *Thank you to the talented artist for creating this wonderful piece!*
                            `), 2000);
                        }
                        break;

                    case 'status':
                        if (widget.config && widget.config.status_url) {
                            try {
                                const response = await fetch(widget.config.status_url);
                                const status = await response.json();
                                this.showModal('🔍 Service Status', this.renderMarkdown(`
                                    # Service Status

                                    **Status**: ${status.status || 'Unknown'}
                                    **Last Check**: ${new Date().toLocaleString()}

                                    The cactus plant represents growth and resilience.
                                    Just like this plant, the services keep growing stronger!
                                `));
                            } catch (error) {
                                this.showModal('🔍 Service Status', this.renderMarkdown(`
                                    # Service Status

                                    **Status**: 🔴 Offline
                                    **Error**: Unable to check status

                                    The cactus droops slightly, waiting for the service to return.
                                `));
                            }
                        }
                        break;

                    case 'online':
                        if (widget.config && widget.config.status_url) {
                            try {
                                const response = await fetch(widget.config.status_url);
                                const isOnline = response.ok;
                                this.showModal('🤖 Bot Status', this.renderMarkdown(`
                                    # Lilith Bot Status

                                    **Status**: ${isOnline ? '🟢 Online' : '🔴 Offline'}
                                    **Last Check**: ${new Date().toLocaleString()}

                                    ${isOnline ?
                                        'Lilith is awake and ready to chat! 💕\n\n[Chat with Lilith](https://t.me/dcmaidbot)' :
                                        'Lilith is currently sleeping. Please try again later! 😴'
                                    }
                                `));
                            } catch (error) {
                                this.showModal('🤖 Bot Status', this.renderMarkdown(`
                                    # Lilith Bot Status

                                    **Status**: 🔴 Offline
                                    **Error**: Unable to reach bot

                                    Lilith seems to be taking a nap. Check back soon!
                                `));
                            }
                        }
                        break;

                    default:
                        console.log(`Unknown widget type: ${widget.type}`);
                }
            }

            async getVersion() {
                try {
                    // Fallback version since package.json might not be accessible
                    return 'v0.1.0-dev';
                } catch (error) {
                    return 'v0.1.0-dev';
                }
            }

            async getLatestCommit() {
                try {
                    const response = await fetch('https://api.github.com/repos/dcversus/dcmaidbot/commits/main');
                    const commit = await response.json();
                    return {
                        hash: commit.sha.substring(0, 7),
                        message: commit.commit.message.split('\n')[0],
                        author: commit.commit.author.name,
                        date: new Date(commit.commit.author.date).toLocaleDateString(),
                        url: commit.html_url
                    };
                } catch (error) {
                    return {
                        hash: 'unknown',
                        message: 'Unable to fetch commit data',
                        author: 'Unknown',
                        date: new Date().toLocaleDateString(),
                        url: 'https://github.com/dcversus/dcmaidbot'
                    };
                }
            }

            handleEasterEggClick(easterEgg) {
                if (this.foundEasterEggs.has(easterEgg.id)) return;

                this.foundEasterEggs.add(easterEgg.id);
                this.assetLoader.saveProgress(this.discoveredLocations, this.foundEasterEggs);

                // Update UI
                const zone = document.querySelector(`[data-easter-egg-id="${easterEgg.id}"]`);
                if (zone) {
                    zone.classList.add('found');
                }

                // Play sound and show modal
                this.audioManager.playEasterEgg();
                this.showModal(
                    `🥚 Easter Egg Found!`,
                    this.renderMarkdown(easterEgg.config.content || 'Easter egg discovered!')
                );
            }

            buildFloorNavigation(floors) {
                const container = document.getElementById('floorButtons');
                container.innerHTML = '';

                floors.forEach(floor => {
                    const button = document.createElement('button');
                    button.className = 'floor-button';
                    button.textContent = `Floor ${floor}`;
                    button.dataset.floor = floor;

                    button.addEventListener('click', () => this.navigateToFloor(floor));

                    container.appendChild(button);
                });

                // Show current floor as active
                if (floors.length > 0) {
                    this.currentFloor = Math.max(...floors.map(f => parseInt(f)));
                    this.updateFloorNavigation();
                }

                document.getElementById('floorNavigation').style.display = 'block';
            }

            navigateToFloor(floor) {
                this.currentFloor = floor;
                this.updateFloorNavigation();

                // Find first location on this floor and scroll to it
                const firstLocation = document.querySelector(`[data-floor="${floor}"]`);
                if (firstLocation) {
                    firstLocation.scrollIntoView({ behavior: 'smooth' });
                }
            }

            updateFloorNavigation() {
                document.querySelectorAll('.floor-button').forEach(button => {
                    button.classList.toggle('active', parseInt(button.dataset.floor) === this.currentFloor);
                });
            }

            setupEventListeners() {
                // Modal close events
                document.getElementById('modalClose').addEventListener('click', () => this.hideModal());
                document.getElementById('modalOverlay').addEventListener('click', (e) => {
                    if (e.target === e.currentTarget) {
                        this.hideModal();
                    }
                });

                // Location discovery observer
                this.setupDiscoveryObserver();

                // Keyboard navigation
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.hideModal();
                    }
                });
            }

            setupTileInteractions() {
                // Add tile interaction listeners to all location containers
                const containers = document.querySelectorAll('.location-container');
                containers.forEach(container => {
                    const locationId = container.dataset.locationId;
                    if (!locationId) return;

                    // Mouse enter - hover tile
                    container.addEventListener('mouseenter', () => {
                        this.handleTileHover(locationId, true);
                    });

                    // Mouse leave - back to idle tile
                    container.addEventListener('mouseleave', () => {
                        this.handleTileHover(locationId, false);
                    });

                    // Mouse down - click tile
                    container.addEventListener('mousedown', () => {
                        this.handleTileClick(locationId, true);
                    });

                    // Mouse up - back to hover tile
                    container.addEventListener('mouseup', () => {
                        this.handleTileClick(locationId, false);
                    });
                });
            }

            handleTileHover(locationId, isHovering) {
                const state = isHovering ? 'hover' : 'idle';
                this.tileManager.setLocationTile(locationId, state);
            }

            handleTileClick(locationId, isPressed) {
                const state = isPressed ? 'click' : 'hover';
                this.tileManager.setLocationTile(locationId, state);

                // Play click sound
                if (isPressed) {
                    this.audioManager.playClick();
                }
            }

            setupDiscoveryObserver() {
                const options = {
                    root: null,
                    rootMargin: '0px',
                    threshold: 0.5
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const locationId = entry.target.dataset.locationId;
                            const floor = parseInt(entry.target.dataset.floor);

                            this.currentFloor = floor;
                            this.updateFloorNavigation();

                            if (!this.discoveredLocations.has(locationId) && locationId !== 'liliths_room') {
                                this.discoverLocation(locationId);
                            }
                        }
                    });
                }, options);

                // Observe all location sections
                document.querySelectorAll('.location-section').forEach(section => {
                    observer.observe(section);
                });
            }

            discoverLocation(locationId) {
                this.discoveredLocations.add(locationId);
                this.assetLoader.saveProgress(this.discoveredLocations, this.foundEasterEggs);

                const location = this.locations.find(l => l.id === locationId);
                if (location) {
                    this.showLocationDiscovery(location.name);
                }
            }

            showLocationDiscovery(locationName) {
                const overlay = document.getElementById('locationDiscovery');
                const nameElement = document.getElementById('discoveryLocationName');

                nameElement.textContent = locationName.toUpperCase();
                overlay.classList.add('active');

                this.audioManager.playDiscovery();

                setTimeout(() => {
                    overlay.classList.remove('active');
                }, 4000);
            }

            showModal(title, content, autoCloseMs = 0) {
                document.getElementById('modalTitle').textContent = title;
                document.getElementById('modalContent').innerHTML = content;
                document.getElementById('modalOverlay').classList.add('active');

                // Auto-close modal after specified delay (for testing)
                if (autoCloseMs > 0) {
                    setTimeout(() => {
                        this.hideModal();
                    }, autoCloseMs);
                }
            }

            hideModal() {
                document.getElementById('modalOverlay').classList.remove('active');
            }

            renderMarkdown(markdown) {
                if (!markdown) return '';

                // Simple markdown to HTML conversion
                let html = markdown
                    .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/!\[([^\]]*)\]\(([^)]*)\)/g, '<img alt="$1" src="$2">')
                    .replace(/\[([^\]]*)\]\(([^)]*)\)/g, '<a href="$2" target="_blank">$1</a>')
                    .replace(/```([^`]+)```/g, '<pre><code>$1</code></pre>')
                    .replace(/`([^`]+)`/g, '<code>$1</code>')
                    .replace(/^\- (.*$)/gim, '<li>$1</li>')
                    .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>')
                    .replace(/\n\n/g, '</p><p>')
                    .replace(/^/, '<p>')
                    .replace(/$/, '</p>');

                return html;
            }

            loadProgress() {
                try {
                    const discovered = localStorage.getItem('discovered_locations');
                    const eggs = localStorage.getItem('found_easter_eggs');

                    if (discovered) {
                        this.discoveredLocations = new Set(JSON.parse(discovered));
                    }

                    if (eggs) {
                        this.foundEasterEggs = new Set(JSON.parse(eggs));
                    }
                } catch (e) {
                    console.warn('Failed to load progress:', e);
                }
            }

            saveProgress() {
                try {
                    localStorage.setItem('discovered_locations', JSON.stringify([...this.discoveredLocations]));
                    localStorage.setItem('found_easter_eggs', JSON.stringify([...this.foundEasterEggs]));
                } catch (e) {
                    console.warn('Failed to save progress:', e);
                }
            }

            hideLoading() {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('worldContainer').style.display = 'block';
            }

            showError(message) {
                document.getElementById('loading').innerHTML = `
                    <div class="error">
                        <h3>⚠️ Error</h3>
                        <p>${message}</p>
                        <button onclick="location.reload()" style="margin-top: 10px; padding: 8px 16px; background: var(--accent-pink); border: none; border-radius: 4px; cursor: pointer;">Reload</button>
                    </div>
                `;
            }

            // ============================================
            // CANVAS WIDGET SYSTEM
            // ============================================

            createClockCanvas(widget, container) {
                const canvas = document.createElement('canvas');
                canvas.width = widget.size.width;
                canvas.height = widget.size.height;
                canvas.className = 'widget-canvas';
                canvas.style.position = 'absolute';
                canvas.style.top = '0';
                canvas.style.left = '0';
                canvas.style.pointerEvents = 'none';
                canvas.style.zIndex = '10';

                container.appendChild(canvas);

                // Start clock updates
                this.updateClockCanvas(canvas, widget);
                setInterval(() => this.updateClockCanvas(canvas, widget), 1000);

                return canvas;
            }

            updateClockCanvas(canvas, widget) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;

                // Clear canvas
                ctx.clearRect(0, 0, width, height);

                // Get current server time (approximate)
                const now = new Date();

                // Set up pixel art style
                ctx.imageSmoothingEnabled = false;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Draw clock background
                ctx.fillStyle = '#2a1810';
                ctx.fillRect(8, 8, width - 16, height - 16);

                // Draw clock border
                ctx.strokeStyle = '#8b6914';
                ctx.lineWidth = 2;
                ctx.strokeRect(6, 6, width - 12, height - 12);

                // Draw time in pixel font style
                const timeString = now.toLocaleTimeString('en-US', {
                    hour12: false,
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });

                // Main time display
                ctx.fillStyle = '#ffeb3b';
                ctx.font = 'bold 14px monospace';
                ctx.fillText(timeString, width / 2, height / 2 - 8);

                // Date display
                const dateString = now.toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric'
                });

                ctx.fillStyle = '#ffffff';
                ctx.font = '10px monospace';
                ctx.fillText(dateString, width / 2, height / 2 + 8);

                // Draw clock hands (simplified)
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) / 3;

                // Hour hand
                const hours = now.getHours() % 12;
                const hourAngle = (hours * Math.PI / 6) + (now.getMinutes() * Math.PI / 360) - Math.PI / 2;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(hourAngle) * radius * 0.5,
                    centerY + Math.sin(hourAngle) * radius * 0.5
                );
                ctx.stroke();

                // Minute hand
                const minuteAngle = (now.getMinutes() * Math.PI / 30) - Math.PI / 2;
                ctx.strokeStyle = '#ffeb3b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(minuteAngle) * radius * 0.7,
                    centerY + Math.sin(minuteAngle) * radius * 0.7
                );
                ctx.stroke();

                // Center dot
                ctx.fillStyle = '#ff4444';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            createStatusCanvas(widget, container) {
                const canvas = document.createElement('canvas');
                canvas.width = widget.size.width;
                canvas.height = widget.size.height;
                canvas.className = 'widget-canvas';
                canvas.style.position = 'absolute';
                canvas.style.top = '0';
                canvas.style.left = '0';
                canvas.style.pointerEvents = 'none';
                canvas.style.zIndex = '10';

                container.appendChild(canvas);
                this.updateStatusCanvas(canvas, widget);

                return canvas;
            }

            updateStatusCanvas(canvas, widget) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;

                // Clear canvas
                ctx.clearRect(0, 0, width, height);

                // Set up pixel art style
                ctx.imageSmoothingEnabled = false;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Background
                ctx.fillStyle = 'rgba(46, 125, 50, 0.9)';
                ctx.fillRect(4, 4, width - 8, height - 8);

                // Border
                ctx.strokeStyle = '#81c784';
                ctx.lineWidth = 2;
                ctx.strokeRect(2, 2, width - 4, height - 4);

                // Status text
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 12px monospace';

                // Get actual status from application
                const status = this.getApplicationStatus();

                // Wrap text if needed
                const maxWidth = width - 12;
                const words = status.split(' ');
                let line = '';
                let y = height / 2 - 8;

                for (let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = ctx.measureText(testLine);
                    const testWidth = metrics.width;

                    if (testWidth > maxWidth && n > 0) {
                        ctx.fillText(line, width / 2, y);
                        line = words[n] + ' ';
                        y += 14;
                    } else {
                        line = testLine;
                    }
                }
                ctx.fillText(line, width / 2, y);
            }

            createTextCanvas(widget, container) {
                const canvas = document.createElement('canvas');
                canvas.width = widget.size.width;
                canvas.height = widget.size.height;
                canvas.className = 'widget-canvas';
                canvas.style.position = 'absolute';
                canvas.style.top = '0';
                canvas.style.left = '0';
                canvas.style.pointerEvents = 'none';
                canvas.style.zIndex = '10';

                container.appendChild(canvas);
                this.updateTextCanvas(canvas, widget);

                return canvas;
            }

            updateTextCanvas(canvas, widget) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;

                // Clear canvas
                ctx.clearRect(0, 0, width, height);

                // Set up pixel art style
                ctx.imageSmoothingEnabled = false;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Background based on widget type
                let bgColor, textColor, title;

                switch (widget.type) {
                    case 'hash':
                        bgColor = '#1a237e';
                        textColor = '#c5cae9';
                        title = 'HASH';
                        break;
                    case 'version':
                        bgColor = '#263238';
                        textColor = '#b0bec5';
                        title = 'VER';
                        break;
                    default:
                        bgColor = '#424242';
                        textColor = '#eeeeee';
                        title = 'INFO';
                }

                // Background
                ctx.fillStyle = bgColor;
                ctx.fillRect(2, 2, width - 4, height - 4);

                // Border
                ctx.strokeStyle = textColor;
                ctx.lineWidth = 1;
                ctx.strokeRect(2, 2, width - 4, height - 4);

                // Title
                ctx.fillStyle = textColor;
                ctx.font = 'bold 8px monospace';
                ctx.fillText(title, width / 2, 8);

                // Content
                ctx.font = '10px monospace';

                if (widget.type === 'hash') {
                    // Display short hash
                    ctx.fillText('abc1234', width / 2, height / 2);
                } else if (widget.type === 'version') {
                    // Display version
                    ctx.fillText('v0.1.0', width / 2, height / 2);
                }
            }

            getApplicationStatus() {
                // Return current application status
                return 'SYSTEM ONLINE';
            }

            // ============================================
            // PROMPT SYSTEM DEBUGGING
            // ============================================

            testPromptSystem() {
                console.log('🧪 Testing Prompt System...');

                if (!this.promptManager) {
                    console.error('❌ PromptManager not initialized');
                    return;
                }

                // Test location prompt generation
                if (this.locations && this.locations.length > 0) {
                    const testLocation = this.locations[0];
                    console.log(`📍 Testing location: ${testLocation.name}`);

                    const idlePrompt = this.promptManager.generateLocationPrompt(testLocation, 'idle');
                    const hoverPrompt = this.promptManager.generateLocationPrompt(testLocation, 'hover');
                    const clickPrompt = this.promptManager.generateLocationPrompt(testLocation, 'click');

                    console.log(`📝 Idle prompt (${idlePrompt.length} chars):`, idlePrompt);
                    console.log(`📝 Hover prompt (${hoverPrompt.length} chars):`, hoverPrompt);
                    console.log(`📝 Click prompt (${clickPrompt.length} chars):`, clickPrompt);

                    // Test widget-specific prompts
                    if (testLocation.widgets && testLocation.widgets.length > 0) {
                        const testWidget = testLocation.widgets[0];
                        console.log(`🔧 Testing widget: ${testWidget.name} (${testWidget.type})`);

                        const widgetIdle = this.promptManager.generateWidgetSpecificPrompt(testWidget, 'idle');
                        const widgetHover = this.promptManager.generateWidgetSpecificPrompt(testWidget, 'hover');
                        const widgetClick = this.promptManager.generateWidgetSpecificPrompt(testWidget, 'click');

                        console.log(`🎨 Widget idle (${widgetIdle.length} chars):`, widgetIdle);
                        console.log(`🎨 Widget hover (${widgetHover.length} chars):`, widgetHover);
                        console.log(`🎨 Widget click (${widgetClick.length} chars):`, widgetClick);
                    }

                    // Test prompt concatenation
                    const concatenated = this.promptManager.concatenatePrompts(idlePrompt, hoverPrompt, clickPrompt);
                    console.log(`🔗 Concatenated prompt (${concatenated.length} chars):`, concatenated);

                    // Show cache info
                    const cacheInfo = this.promptManager.getPromptCacheInfo();
                    console.log('💾 Cache info:', cacheInfo);
                } else {
                    console.warn('⚠️ No locations found for prompt testing');
                }

                console.log('✅ Prompt system test complete');
            }

            testWidgetPrompts() {
                console.log('🧪 Testing Widget Prompts...');

                if (!this.promptManager) {
                    console.error('❌ PromptManager not initialized');
                    return;
                }

                // Test all widget types
                const widgetTypes = ['time', 'status', 'changelog', 'link', 'story', 'music', 'online', 'version', 'hash'];
                const states = ['idle', 'hover', 'click'];

                widgetTypes.forEach(type => {
                    console.log(`🔧 Testing widget type: ${type}`);
                    states.forEach(state => {
                        const mockWidget = {
                            id: `test_${type}`,
                            type: type,
                            name: `Test ${type}`,
                            position: { x: 100, y: 100 },
                            size: { width: 64, height: 64 },
                            description: `Test ${type} widget`
                        };

                        const prompt = this.promptManager.generateWidgetPrompt(mockWidget, state);
                        console.log(`  ${state}: ${prompt.substring(0, 100)}${prompt.length > 100 ? '...' : ''}`);
                    });
                });

                console.log('✅ Widget prompts test complete');
            }

            exportPromptSystem() {
                console.log('📤 Exporting Prompt System...');

                if (!this.promptManager) {
                    console.error('❌ PromptManager not initialized');
                    return null;
                }

                const exportData = {
                    timestamp: new Date().toISOString(),
                    locations: [],
                    widgetTemplates: {}
                };

                // Export location prompts
                this.locations.forEach(location => {
                    const locationData = {
                        id: location.id,
                        name: location.name,
                        prompts: {
                            idle: this.promptManager.generateLocationPrompt(location, 'idle'),
                            hover: this.promptManager.generateLocationPrompt(location, 'hover'),
                            click: this.promptManager.generateLocationPrompt(location, 'click')
                        }
                    };

                    if (location.widgets) {
                        locationData.widgets = location.widgets.map(widget => ({
                            id: widget.id,
                            type: widget.type,
                            name: widget.name,
                            prompts: {
                                idle: this.promptManager.generateWidgetSpecificPrompt(widget, 'idle'),
                                hover: this.promptManager.generateWidgetSpecificPrompt(widget, 'hover'),
                                click: this.promptManager.generateWidgetSpecificPrompt(widget, 'click')
                            }
                        }));
                    }

                    exportData.locations.push(locationData);
                });

                // Export widget templates
                exportData.widgetTemplates = Object.fromEntries(this.promptManager.widgetPromptTemplates);

                console.log('✅ Prompt system exported');
                return exportData;
            }

            // ============================================
            // IMAGE COMPOSITION DEBUGGING
            // ============================================

            async testImageComposition() {
                console.log('🎨 Testing Image Composition System...');

                if (!this.imageCompositionManager) {
                    console.error('❌ ImageCompositionManager not initialized');
                    return;
                }

                // Test composite tile generation
                if (this.locations && this.locations.length > 0) {
                    const testLocation = this.locations[0];
                    console.log(`📍 Testing composite tile for: ${testLocation.name}`);

                    try {
                        const idleComposite = await this.imageCompositionManager.createCompositeTile(testLocation, 'idle');
                        console.log(`✅ Idle composite created: ${idleComposite ? 'SUCCESS' : 'FAILED'}`);

                        const hoverComposite = await this.imageCompositionManager.createCompositeTile(testLocation, 'hover');
                        console.log(`✅ Hover composite created: ${hoverComposite ? 'SUCCESS' : 'FAILED'}`);

                        const clickComposite = await this.imageCompositionManager.createCompositeTile(testLocation, 'click');
                        console.log(`✅ Click composite created: ${clickComposite ? 'SUCCESS' : 'FAILED'}`);

                        // Show cache info
                        const cacheInfo = this.imageCompositionManager.getCacheInfo();
                        console.log('💾 Composition cache info:', cacheInfo);

                        return {
                            idle: idleComposite,
                            hover: hoverComposite,
                            click: clickComposite
                        };

                    } catch (error) {
                        console.error(`❌ Error testing image composition: ${error.message}`);
                        return null;
                    }
                } else {
                    console.warn('⚠️ No locations found for image composition testing');
                }

                console.log('✅ Image composition test complete');
            }

            async testPregeneration() {
                console.log('🎨 Testing Tile Pregeneration...');

                if (!this.imageCompositionManager) {
                    console.error('❌ ImageCompositionManager not initialized');
                    return;
                }

                if (this.locations && this.locations.length > 0) {
                    const testLocation = this.locations[0];
                    console.log(`📍 Pregenerating tiles for: ${testLocation.name}`);

                    try {
                        const pregeneratedTiles = await this.imageCompositionManager.pregenerateLocationTiles(testLocation);
                        console.log('✅ Pregenerated tiles:', {
                            idle: pregeneratedTiles.idle ? 'SUCCESS' : 'FAILED',
                            hover: pregeneratedTiles.hover ? 'SUCCESS' : 'FAILED',
                            click: pregeneratedTiles.click ? 'SUCCESS' : 'FAILED'
                        });

                        return pregeneratedTiles;

                    } catch (error) {
                        console.error(`❌ Error testing pregerneration: ${error.message}`);
                        return null;
                    }
                } else {
                    console.warn('⚠️ No locations found for pregerneration testing');
                }

                console.log('✅ Pregerneration test complete');
            }

            showCompositeTiles() {
                console.log('🖼️ Displaying Composite Tiles...');

                if (!this.imageCompositionManager) {
                    console.error('❌ ImageCompositionManager not initialized');
                    return;
                }

                const cacheInfo = this.imageCompositionManager.getCacheInfo();
                console.log(`📋 Found ${cacheInfo.size} cached composite tiles`);

                cacheInfo.keys.forEach(key => {
                    const imageUrl = this.imageCompositionManager.canvasCache.get(key);
                    console.log(`🎨 Composite tile: ${key} -> ${imageUrl ? 'VALID' : 'NULL'}`);
                });

                return cacheInfo;
            }

            clearCompositionCache() {
                if (this.imageCompositionManager) {
                    this.imageCompositionManager.clearCache();
                    console.log('🗑️ Composition cache cleared');
                } else {
                    console.error('❌ ImageCompositionManager not initialized');
                }
            }
        }

        // ============================================
        // INITIALIZATION
        // ============================================

        document.addEventListener('DOMContentLoaded', () => {
            window.worldManager = new WorldManager();

            // Make worldManager available for debugging
            window.testPromptSystem = () => window.worldManager.testPromptSystem();
            window.testWidgetPrompts = () => window.worldManager.testWidgetPrompts();
            window.exportPromptSystem = () => window.worldManager.exportPromptSystem();

            // Image composition debugging
            window.testImageComposition = () => window.worldManager.testImageComposition();
            window.testPregeneration = () => window.worldManager.testPregeneration();
            window.showCompositeTiles = () => window.worldManager.showCompositeTiles();
            window.clearCompositionCache = () => window.worldManager.clearCompositionCache();

            // Initialize audio system with Web Audio API generated sounds
            setTimeout(() => {
                console.log('🔊 Starting sound generation...');
                console.log('Audio manager initialized:', window.worldManager.audioManager.initialized);
                console.log('Audio context state:', window.worldManager.audioManager.context?.state);

                // Test prompt system after everything is loaded
                setTimeout(() => {
                    console.log('🧪 Testing prompt system...');
                    window.worldManager.testPromptSystem();
                }, 2000);

                // Create retro game style sounds with proper frequencies
                try {
                    window.worldManager.audioManager.generateSound('hover', 800, 0.15); // Gentle chime at 800Hz, 150ms
                    console.log('Generated hover sound');
                } catch (e) {
                    console.error('Failed to generate hover sound:', e);
                }

                try {
                    window.worldManager.audioManager.generateSound('click', 1200, 0.2); // Retro click at 1200Hz, 200ms
                    console.log('Generated click sound');
                } catch (e) {
                    console.error('Failed to generate click sound:', e);
                }

                try {
                    window.worldManager.audioManager.generateSound('discovery', 600, 0.4); // Dark Souls discovery at 600Hz, 400ms
                    console.log('Generated discovery sound');
                } catch (e) {
                    console.error('Failed to generate discovery sound:', e);
                }

                try {
                    window.worldManager.audioManager.generateSound('quest-complete', 1000, 0.6); // WoW quest complete at 1000Hz, 600ms
                    console.log('Generated quest-complete sound');
                } catch (e) {
                    console.error('Failed to generate quest-complete sound:', e);
                }

                console.log('🔊 All retro game sounds generated!');

                // Start background music
                console.log('🎵 Starting background music...');
                window.worldManager.audioManager.playBackgroundMusic();
            }, 100);
        });
    </script>

    <!-- Enhanced Interactive State Management -->
    <script src="enhanced_state_management.js"></script>
    <!-- Enhanced Modal System -->
    <script src="enhanced_modal_system.js"></script>
</body>
</html>
